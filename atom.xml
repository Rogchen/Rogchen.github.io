<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rogchen的博客</title>
  <icon>https://www.gravatar.com/avatar/46ef8ab176ec29caba6d991fe9c608e9</icon>
  <subtitle>空想改变不了平庸的命运，实践敲开卓越的大门</subtitle>
  <link href="https://rogchen.github.com/atom.xml" rel="self"/>
  
  <link href="https://rogchen.github.com/"/>
  <updated>2021-03-26T02:52:44.925Z</updated>
  <id>https://rogchen.github.com/</id>
  
  <author>
    <name>Rogchen</name>
    <email>chenhk128@163com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis笔记</title>
    <link href="https://rogchen.github.com/2021/03/22/redis-all/"/>
    <id>https://rogchen.github.com/2021/03/22/redis-all/</id>
    <published>2021-03-22T05:47:53.291Z</published>
    <updated>2021-03-26T02:52:44.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis是什么"><a href="#redis是什么" class="headerlink" title="redis是什么"></a>redis是什么</h2><p>redis是使用c语言开发的一个开源（遵从bsd协议）高性能键值对的内存数据库，可以用作数据库、缓存、消息中间件等；它是一种NoSQL非关系型数据库。</p><blockquote><p>优点:</p></blockquote><ul><li>性能优秀，数据再内存中，读写非常快，支持并发10w qps。</li><li>单进程单线程，是线程安全的，采用IO<a href="https://baidu.com" target="_blank" rel="noopener">多路复用</a>机制。</li><li>丰富的数据类型，支持字符串、散列(hashes)、列表(list)、集合(sets)、有序集合（sorted sets）等。</li><li>支持数据持久化，将内存中数据保存到磁盘中，重启时加载。</li><li>主从复制，哨兵，高可用。</li><li>可以用分布式锁。</li><li>可以作为消息中间件使用，支持分布订阅。</li></ul><hr><h3 id="五种数据类型"><a href="#五种数据类型" class="headerlink" title="五种数据类型"></a>五种数据类型</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis是什么&quot;&gt;&lt;a href=&quot;#redis是什么&quot; class=&quot;headerlink&quot; title=&quot;redis是什么&quot;&gt;&lt;/a&gt;redis是什么&lt;/h2&gt;&lt;p&gt;redis是使用c语言开发的一个开源（遵从bsd协议）高性能键值对的内存数据库，可以用作数据</summary>
      
    
    
    
    
    <category term="redis" scheme="https://rogchen.github.com/tags/redis/"/>
    
    <category term="哨兵" scheme="https://rogchen.github.com/tags/%E5%93%A8%E5%85%B5/"/>
    
    <category term="sentinel" scheme="https://rogchen.github.com/tags/sentinel/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记-&gt;同步锁synchronized/volatile</title>
    <link href="https://rogchen.github.com/2020/12/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E9%94%81synchronized/"/>
    <id>https://rogchen.github.com/2020/12/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%90%8C%E6%AD%A5%E9%94%81synchronized/</id>
    <published>2020-12-21T01:41:42.334Z</published>
    <updated>2020-12-21T01:41:42.334Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized-关键字原理"><a href="#synchronized-关键字原理" class="headerlink" title="synchronized 关键字原理"></a>synchronized 关键字原理</h2><p>众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p><ul><li>同步普通方法，锁的是当前对象。在范围操作符之后，返回类型声明之前使用。每次只能有一个线程进入该方法，此时线程获得的是成员锁。</li></ul><a id="more"></a><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>同步静态方法，如果当前线程进入，那么其他线程在该类中所有操作不能进行，包括静态变量和静态方法，此时当前线程获得的是对象锁。</p><figure class="highlight plain"><figcaption><span>class syncClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    public void method() &#123;</span><br><span class="line">        synchronized(syncClass.class) &#123;</span><br><span class="line">            //doSomething</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步块，锁的是 () 中的对象。每次只能有一个线程进入该代码块，此时线程获得的是成员锁。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">synMethod</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(arg) &#123;</span><br><span class="line">        <span class="comment">//doSomething</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>实现原理： JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。</p><p>具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。</p><p>其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p><p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。</p><p>锁优化</p><p>synchronized 很多都称之为重量锁，JDK1.6 中对 synchronized 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了偏向锁和轻量锁。</p><h2 id="volatile-java关键字"><a href="#volatile-java关键字" class="headerlink" title="volatile java关键字"></a>volatile java关键字</h2><p>volatile 关键字只能保证可见性，顺序性，不能保证原子性。<br>volatile 关键字的作用是禁止指令的重排序，强制从公共堆栈中取得变量的值，而不是从线程私有的数据栈中取变量的值。<br>volatile与synchronized的区别如下：</p><p>volatile 不会发生线程阻塞，而 synchronized 会发生线程阻塞。<br>volatile 只能修饰变量，而 synchronized 可以修饰方法、代码块等。<br>volatile 不能保证原子性（不能保证线程安全），而 synchronized 可以保证原子性。<br>volatile 解决的是变量在多线程之间的可见性，而 synchronized 解决的是多线程之间访问资源的同步性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">     private static volatile Singleton singleton;</span><br><span class="line"></span><br><span class="line">     private Singleton() &#123;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public static Singleton getInstance() &#123;</span><br><span class="line">         if (singleton == null) &#123;</span><br><span class="line">             synchronized (Singleton.class) &#123;</span><br><span class="line">                 if (singleton == null) &#123;</span><br><span class="line">                     singleton = new Singleton();</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return singleton;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h2 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h2><p>  synchronized是隐式锁，在需要同步的对象中加入此控制，而lock是显示锁，需要显示指定起始位置和终止位置。</p><p>使用lock时在finally中必须释放锁，不然容易造成线程死锁；而使用synchronized时，获取锁的线程会在执行完同步代码后释放锁（或者JVM会在线程执行发生异常时释放锁）。<br>使用lock时线程不会一直等待；而使用synchronized时，假设A线程获得锁后阻塞，其他线程会一直等待。<br>lock可重入、可中断、可公平也可不公平；而synchronized可重入但不可中断、非公平。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;synchronized-关键字原理&quot;&gt;&lt;a href=&quot;#synchronized-关键字原理&quot; class=&quot;headerlink&quot; title=&quot;synchronized 关键字原理&quot;&gt;&lt;/a&gt;synchronized 关键字原理&lt;/h2&gt;&lt;p&gt;众所周知 synchronized 关键字是解决并发问题常用解决方案，有以下三种使用方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步普通方法，锁的是当前对象。在范围操作符之后，返回类型声明之前使用。每次只能有一个线程进入该方法，此时线程获得的是成员锁。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="syschronized" scheme="https://rogchen.github.com/tags/syschronized/"/>
    
    <category term="lock" scheme="https://rogchen.github.com/tags/lock/"/>
    
    <category term="volatile" scheme="https://rogchen.github.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>阅读笔记-&gt;hashmap 的key跟扩容</title>
    <link href="https://rogchen.github.com/2020/12/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-hashmap%E7%9A%84%E6%89%A9%E5%AE%B9/"/>
    <id>https://rogchen.github.com/2020/12/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-hashmap%E7%9A%84%E6%89%A9%E5%AE%B9/</id>
    <published>2020-12-21T01:41:42.332Z</published>
    <updated>2020-12-21T01:41:42.332Z</updated>
    
    <content type="html"><![CDATA[<p>1、map-&gt;hashmap HashMap 底层是基于数组和链表实现的。其中有两个重要的参数：容量；负载因子.容量的默认大小是 16，负载因子是 0.75，当 HashMap 的 size &gt; 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。<br>key是采用传入参数的hashcode 在进行取模运算，在参数的hash是2^n时候跟位运算是一样的，所以采用位运算来做取模。</p><h2 id="初始化-构造方法"><a href="#初始化-构造方法" class="headerlink" title="初始化 构造方法"></a>初始化 构造方法</h2><p>首先，int n = cap -1是为了防止cap已经是2的幂时，执行完后面的几条无符号右移操作之后，返回的capacity是这个cap的2倍，因为cap已经是2的幂了，就已经满足条件了。 如果不懂可以往下看完几个无符号移位后再回来看。<br>比如容量是8 符合2^n次方，但是也满足了扩容。<br>所以不直接用2^n来，而是采用位运算</p><a id="more"></a><p>原始计算： n=n-1  -&gt;  7=8-1<br>原始值          0000 1000</p><p>| n|&gt;&gt;&gt;1 右移1位  0000 0111 </p><h2 id="或运算-0000-1000"><a href="#或运算-0000-1000" class="headerlink" title="|      或运算      0000 1000"></a>|      或运算      0000 1000</h2><pre><code>值         0000 1111</code></pre><hr><p>| n|&gt;&gt;&gt;2 右移2位  0000 0011    </p><h2 id="或运算-0000-1111"><a href="#或运算-0000-1111" class="headerlink" title="|       或运算      0000 1111"></a>|       或运算      0000 1111</h2><pre><code>值为   0000 1111    </code></pre><hr><p>| n|&gt;&gt;&gt;4 右移2位  0000 0011    </p><h2 id="或运算-0000-1111-1"><a href="#或运算-0000-1111-1" class="headerlink" title="|       或运算      0000 1111"></a>|       或运算      0000 1111</h2><pre><code>值为   0000 1111                </code></pre><hr><p>| n|&gt;&gt;&gt;8 右移8位  0000 0011    </p><h2 id="或运算-0000-1111-2"><a href="#或运算-0000-1111-2" class="headerlink" title="|       或运算      0000 1111"></a>|       或运算      0000 1111</h2><pre><code>值为   0000 1111    </code></pre><hr><p>| n|&gt;&gt;&gt;16右移16位 0000 0011    </p><h2 id="或运算-0000-1111-3"><a href="#或运算-0000-1111-3" class="headerlink" title="|       或运算      0000 1111"></a>|       或运算      0000 1111</h2><pre><code>值为   0000 1111                            </code></pre><hr><h2 id="最终值为-n-n-1-gt-16-15-1-满足2-n-1"><a href="#最终值为-n-n-1-gt-16-15-1-满足2-n-1" class="headerlink" title=" 最终值为 n=n+1  -&gt; 16=15+1  满足2^n-1"></a> 最终值为 n=n+1  -&gt; 16=15+1  满足2^n-1</h2><p>首先会将传入的 Key 做 hash 运算计算出 hashcode,然后根据数组长度取模计算出在数组中的 index 下标。</p><p>由于在计算中位运算比取模运算效率高的多，所以 HashMap 规定数组的长度为 2^n 。这样用 2^n - 1 做位运算与取模效果一致，并且效率还要高出许多。</p><p>由于数组的长度有限，所以难免会出现不同的 Key 通过运算得到的 index 相同，这种情况可以利用链表来解决，HashMap 会在 table[index]处形成链表，采用头插法将数据插入到链表中</p><h1 id="hashset"><a href="#hashset" class="headerlink" title="hashset"></a>hashset</h1><p>hashset是将hashmap整个对象当成key存储，所以hashset的key就无法重复。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、map-&amp;gt;hashmap HashMap 底层是基于数组和链表实现的。其中有两个重要的参数：容量；负载因子.容量的默认大小是 16，负载因子是 0.75，当 HashMap 的 size &amp;gt; 16*0.75 时就会发生扩容(容量和负载因子都可以自由调整)。&lt;br&gt;key是采用传入参数的hashcode 在进行取模运算，在参数的hash是2^n时候跟位运算是一样的，所以采用位运算来做取模。&lt;/p&gt;
&lt;h2 id=&quot;初始化-构造方法&quot;&gt;&lt;a href=&quot;#初始化-构造方法&quot; class=&quot;headerlink&quot; title=&quot;初始化 构造方法&quot;&gt;&lt;/a&gt;初始化 构造方法&lt;/h2&gt;&lt;p&gt;首先，int n = cap -1是为了防止cap已经是2的幂时，执行完后面的几条无符号右移操作之后，返回的capacity是这个cap的2倍，因为cap已经是2的幂了，就已经满足条件了。 如果不懂可以往下看完几个无符号移位后再回来看。&lt;br&gt;比如容量是8 符合2^n次方，但是也满足了扩容。&lt;br&gt;所以不直接用2^n来，而是采用位运算&lt;/p&gt;</summary>
    
    
    
    
    <category term="hashmap" scheme="https://rogchen.github.com/tags/hashmap/"/>
    
    <category term="负载因子" scheme="https://rogchen.github.com/tags/%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90/"/>
    
    <category term="容量" scheme="https://rogchen.github.com/tags/%E5%AE%B9%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>复习笔记-&gt;semaphore/countDownLatch</title>
    <link href="https://rogchen.github.com/2020/12/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95/"/>
    <id>https://rogchen.github.com/2020/12/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B9%B6%E5%8F%91%E6%B5%8B%E8%AF%95/</id>
    <published>2020-12-21T01:41:42.331Z</published>
    <updated>2020-12-21T01:41:42.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发也经常需要跑并发测试，要是每次需要开jmater/loadrunner那这样太麻烦了，这边简单记录一个单元测试，实际生产使用需要对这快在进行优化。</p><h2 id="锁的差别"><a href="#锁的差别" class="headerlink" title="锁的差别"></a>锁的差别</h2><p>synchronized是互斥锁，每次只能有一个线程，semaphore也是同步锁维护的是一个许可集，调用acquire()获取一个许可，release()释放一个许可。</p><h2 id="信号枪"><a href="#信号枪" class="headerlink" title="信号枪"></a>信号枪</h2><p>countDownLatch 信号枪当countDown退到0时候就执行awit的方法。可以用于并发/主线城等待等方式上的使用。<br><a id="more"></a></p><p>单元测试</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 测试信号量() throws InterruptedException &#123;</span><br><span class="line">        <span class="keyword">int</span> threadTotal = <span class="number">20</span>, clientTotal = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//       线程池        </span></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//        定义信号量</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line"><span class="comment">//        定义信号枪--&gt;countDown为0时才执行awit方法，保证主线程的等待</span></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"当前时间："</span>+ <span class="keyword">new</span> Date().toLocaleString());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                    一次只允许进入一个，多余的会等待</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    <span class="comment">// 判断是否正常</span></span><br><span class="line"><span class="comment">//                    System.out.println("当前线程：" + Thread.currentThread().getName());</span></span><br><span class="line"><span class="comment">//                    睡眠2秒</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    semaphore.<span class="built_in">release</span>();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.<span class="built_in">shutdown</span>();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"结束时间："</span>+ <span class="keyword">new</span> Date().toLocaleString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;开发也经常需要跑并发测试，要是每次需要开jmater/loadrunner那这样太麻烦了，这边简单记录一个单元测试，实际生产使用需要对这快在进行优化。&lt;/p&gt;
&lt;h2 id=&quot;锁的差别&quot;&gt;&lt;a href=&quot;#锁的差别&quot; class=&quot;headerlink&quot; title=&quot;锁的差别&quot;&gt;&lt;/a&gt;锁的差别&lt;/h2&gt;&lt;p&gt;synchronized是互斥锁，每次只能有一个线程，semaphore也是同步锁维护的是一个许可集，调用acquire()获取一个许可，release()释放一个许可。&lt;/p&gt;
&lt;h2 id=&quot;信号枪&quot;&gt;&lt;a href=&quot;#信号枪&quot; class=&quot;headerlink&quot; title=&quot;信号枪&quot;&gt;&lt;/a&gt;信号枪&lt;/h2&gt;&lt;p&gt;countDownLatch 信号枪当countDown退到0时候就执行awit的方法。可以用于并发/主线城等待等方式上的使用。&lt;br&gt;</summary>
    
    
    
    
    <category term="countDownLatch" scheme="https://rogchen.github.com/tags/countDownLatch/"/>
    
    <category term="semaphore" scheme="https://rogchen.github.com/tags/semaphore/"/>
    
    <category term="线程池" scheme="https://rogchen.github.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据库的分库分表操作</title>
    <link href="https://rogchen.github.com/2020/12/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>https://rogchen.github.com/2020/12/21/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</id>
    <published>2020-12-21T01:41:42.328Z</published>
    <updated>2020-12-21T01:41:42.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p> 很早就听说了分库分表操作，但是一直没记住，这里只是单纯做个笔记。</p><h2 id="2、读写分离"><a href="#2、读写分离" class="headerlink" title="2、读写分离"></a>2、读写分离</h2><p>将数据库分为主从库，一个主库（Master）用于写数据，多个从库（Slaver）进行轮询读取数据的过程，主从库之间通过某种通讯机制进行数据的同步，是一种常见的数据库架构。读写分离有个问题就是同步问题，有时候我们想要及时返回数据呢？所以我们经常是把一些着急返回的通过代码形式从主库去获取。</p><h3 id="2-1、-为什么要读写分离"><a href="#2-1、-为什么要读写分离" class="headerlink" title="2.1、 为什么要读写分离"></a>2.1、 为什么要读写分离</h3><p>大多数互联网数据操作往往都是读多写少，随着数据的增长，数据库的“读”会首先成为瓶颈。如果我们希望能线性地提升数据库的读性能和写性能，就需要让读写尽可能的不相互影响，各自为政。在使用读写分离之前我们应该考虑使用缓存能不能解决问题。然后再考虑对数据库按照 “读” 和 “写” 进行分组。读写分离意味着将一体的结构的进行分散，在数据量大、高并发的情景中要考虑以下这些问题</p><a id="more"></a><ol><li>如何保证 Master 的高可用，故障转移，熔断限流等。</li><li>读写操作的区分规则，代码层面如何处理好读命令和写命令，尽量无感知无业务入侵。</li><li>数据一致性的容忍度。虽然是数据同步，但是由于网络的不确定性这仍然是一个不可忽视的问题。</li></ol><h2 id="3、分库"><a href="#3、分库" class="headerlink" title="3、分库"></a>3、分库</h2><p>数据库垂直拆分、数据库水平拆分 统称 分库。是指按照特定的条条件和维度，将同一个数据库中的数据拆分到多个数据库（主机）上面以达到分散单库（主机）负载的效果。这样我们变相地降低了数据集的大小，以空间换时间来提升性能。</p><h3 id="3-1、-数据库垂直拆分"><a href="#3-1、-数据库垂直拆分" class="headerlink" title="3.1、 数据库垂直拆分"></a>3.1、 数据库垂直拆分</h3><p>数据库垂直拆分 指的是按照业务对数据库中的表进行分组，同组的放到一个新的数据库（逻辑上，并非实例）中。需要从实际业务出发将大业务分割成小业务。比如商城的整个业务中的 用户相关表，订单相关表，物流相关表 各自独立分类形成 用户系统数据库，订单系统数据库，物流系统数据库。<br><img src="https://raw.githubusercontent.com/Rogchen/rogchen-picture/master/blog-img/readmd/fenku.png" alt="分库"></p><p>这样带来了一些好处： （a）业务清晰，职责单一 （b）易维护，易扩展 （c）数据服务化 。 同时也有一些负面的作用：（a）提高了整个应用的复杂度，而且会形成跨库事务 （b）引发 “木桶效应”，任何一个短板有可能影响整个系统 （c）部分表关系不能 join 只能通过服务相互调用来维系。甚至由于网络问题引发数据不一致。</p><p>在需要进行分库的情况下，通常可优先考虑垂直拆分。</p><h3 id="3-2、-数据库水平拆分"><a href="#3-2、-数据库水平拆分" class="headerlink" title="3.2、 数据库水平拆分"></a>3.2、 数据库水平拆分</h3><p>在数据库垂直拆分后遇到单机数据库性能瓶颈之后，就可以考虑数据库水平拆分了。 之所以先垂直拆分才水平拆分，是因为垂直拆分后数据业务清晰而且单一，更加方便指定水平的标准。比如我们对商城业务垂直拆分后的 用户系统 进行水平拆分就比对整个商城业务进行水平拆分好找维度，我们可以根据用户注册时间的区间、用户的区域或者用户 ID 的范围、 hash 等条件，然后关联相关表的记录将数据进行拆分，如果放在整个商城业务上你是以用户为准还是以订单为准都不太好考虑。</p><p>我们按照每100万为区间对用户系统水平拆分如下：<br><img src="https://raw.githubusercontent.com/Rogchen/rogchen-picture/master/blog-img/readmd/spcf1.png" alt="分库"><br>这种拆分的好处在于： （a）单个库的容量可控 （b）单挑记录保证了数据完整性 （c）数据关系可以通过 join 维持 （d） 避免了跨库事务 ；缺点同样存在：（a）拆分规则对编码有一定的影响 （b）不同业务的分区交互需要统筹设计</p><h2 id="4、-分表"><a href="#4、-分表" class="headerlink" title="4、 分表"></a>4、 分表</h2><p>分表也分为 数据表垂直拆分 和 数据表水平拆分 。</p><h3 id="4-1、-数据表垂直拆分"><a href="#4-1、-数据表垂直拆分" class="headerlink" title="4.1、 数据表垂直拆分"></a>4.1、 数据表垂直拆分</h3><p>数据表垂直拆分就是纵向地把表中的列分成多个表，把表从“宽”变“窄”。一般遵循以下几个点进行拆分：</p><p>冷热分离，把常用的列放在一个表，不常用的放在一个表。<br>大字段列独立存放<br>关联关系的列紧密的放在一起<br>我们把用户表中常用的和不常用的而且大字段分离成两张表：<br><img src="https://raw.githubusercontent.com/Rogchen/rogchen-picture/master/blog-img/readmd/fenbiao.png" alt="分表"></p><h3 id="4-2、-数据表的水平拆分"><a href="#4-2、-数据表的水平拆分" class="headerlink" title="4.2、 数据表的水平拆分"></a>4.2、 数据表的水平拆分</h3><p>表的水平拆分感觉跟库的水平拆分思想上都是一样的，只不过粒度不同。表结构维持不变。也就是说拆分后数据集的并集等于拆分前的数据集。理解了 3.2 章节 之后这个就没有什么可说的了。</p><h2 id="5、-总结"><a href="#5、-总结" class="headerlink" title="5、 总结"></a>5、 总结</h2><p>这里简单阐述了几个数据库优化概念，在实际操作中往往会组合使用。我们在实际操作之前要做好数据量的预估，这样能够根据预测未来数据的增量来进行选型。业务数据增长较小，常用于表的拆分。增长特别大达到上万级别则可以选择分库，比如一些资金积分流水，历史记录之类的。有些时候并不是拆分完就万事大吉了，比如我们按照地区拆分后，A地区业务增长很快业绩很好，而B地区推广不力竞争激烈业绩萧条，造成了数据倾斜。也会影响分库分表的期望效果。这需要建立长效的监控预测机制来应对，甚至根据实际情况及时调整策略。数据拆分还面临分布式的很多问题，分布式事务，高可用，数据一致性，全局唯一性都是应该考虑的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、前言&quot;&gt;&lt;a href=&quot;#1、前言&quot; class=&quot;headerlink&quot; title=&quot;1、前言&quot;&gt;&lt;/a&gt;1、前言&lt;/h2&gt;&lt;p&gt; 很早就听说了分库分表操作，但是一直没记住，这里只是单纯做个笔记。&lt;/p&gt;
&lt;h2 id=&quot;2、读写分离&quot;&gt;&lt;a href=&quot;#2、读写分离&quot; class=&quot;headerlink&quot; title=&quot;2、读写分离&quot;&gt;&lt;/a&gt;2、读写分离&lt;/h2&gt;&lt;p&gt;将数据库分为主从库，一个主库（Master）用于写数据，多个从库（Slaver）进行轮询读取数据的过程，主从库之间通过某种通讯机制进行数据的同步，是一种常见的数据库架构。读写分离有个问题就是同步问题，有时候我们想要及时返回数据呢？所以我们经常是把一些着急返回的通过代码形式从主库去获取。&lt;/p&gt;
&lt;h3 id=&quot;2-1、-为什么要读写分离&quot;&gt;&lt;a href=&quot;#2-1、-为什么要读写分离&quot; class=&quot;headerlink&quot; title=&quot;2.1、 为什么要读写分离&quot;&gt;&lt;/a&gt;2.1、 为什么要读写分离&lt;/h3&gt;&lt;p&gt;大多数互联网数据操作往往都是读多写少，随着数据的增长，数据库的“读”会首先成为瓶颈。如果我们希望能线性地提升数据库的读性能和写性能，就需要让读写尽可能的不相互影响，各自为政。在使用读写分离之前我们应该考虑使用缓存能不能解决问题。然后再考虑对数据库按照 “读” 和 “写” 进行分组。读写分离意味着将一体的结构的进行分散，在数据量大、高并发的情景中要考虑以下这些问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="https://rogchen.github.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="分库" scheme="https://rogchen.github.com/tags/%E5%88%86%E5%BA%93/"/>
    
    <category term="分表" scheme="https://rogchen.github.com/tags/%E5%88%86%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>vim使用</title>
    <link href="https://rogchen.github.com/2020/12/21/user-vim/"/>
    <id>https://rogchen.github.com/2020/12/21/user-vim/</id>
    <published>2020-12-21T01:41:42.326Z</published>
    <updated>2020-12-21T01:41:42.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门操作"><a href="#入门操作" class="headerlink" title="入门操作"></a>入门操作</h1><h2 id="1、输入i进入编辑模式，按下esc-ctrl-c-输入-wq-保存，q！不保存强制退出，wq！强制保存"><a href="#1、输入i进入编辑模式，按下esc-ctrl-c-输入-wq-保存，q！不保存强制退出，wq！强制保存" class="headerlink" title="1、输入i进入编辑模式，按下esc/ctrl+c 输入:wq 保存，q！不保存强制退出，wq！强制保存"></a>1、输入i进入编辑模式，按下esc/ctrl+c 输入:wq 保存，q！不保存强制退出，wq！强制保存</h2><h1 id="操作提升"><a href="#操作提升" class="headerlink" title="操作提升"></a>操作提升</h1><h2 id="2、-set-showmode-回车-即可显示提示。"><a href="#2、-set-showmode-回车-即可显示提示。" class="headerlink" title="2、 :set showmode+回车 即可显示提示。"></a>2、 :set showmode+回车 即可显示提示。</h2><h2 id="3、粘贴复制删除等操作"><a href="#3、粘贴复制删除等操作" class="headerlink" title="3、粘贴复制删除等操作"></a>3、粘贴复制删除等操作</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----命令模式：----</span><br><span class="line">yy复制光标所在行</span><br><span class="line"><span class="number">2</span>yy复制光标所在行开始的<span class="number">2</span>行</span><br><span class="line">p粘贴</span><br><span class="line">dd删除光标所在行（实际是剪切）</span><br><span class="line"><span class="number">3</span>dd删除光标所在行开始的<span class="number">3</span>行（剪切）</span><br><span class="line">x删除当前光标所在的字符</span><br><span class="line">X（大写)删除当前光标前一个字符</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="4、光标的移动"><a href="#4、光标的移动" class="headerlink" title="4、光标的移动"></a>4、光标的移动</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----命令模式：----</span><br><span class="line"> </span><br><span class="line">h 左移   <span class="keyword">j </span>下移 k 上移  l 右移 （四个箭头也可以上下左右移动）</span><br><span class="line">H 当前屏幕第一行</span><br><span class="line">M 当前屏幕中间</span><br><span class="line">L 当前屏幕最后一行</span><br><span class="line">ctrl+f  往下翻页</span><br><span class="line">ctrl+<span class="keyword">b </span> 网上翻页</span><br><span class="line">G       定位到最后一行（整个文档最后一行）</span><br><span class="line"><span class="number">5</span>G      定位到第<span class="number">5</span>行</span><br><span class="line">gg      定位到第一行（整个文档第一行）</span><br><span class="line">w       跳到下一个单词</span><br><span class="line"><span class="keyword">b </span>      跳到上一个单词</span><br><span class="line">&#123;       移动到上一个代码块</span><br><span class="line">&#125;       移动到下一个代码块</span><br><span class="line">v、V    先按v再用上下箭头选中几行，再&gt;         这几行集体右移，再.继续右移 </span><br><span class="line">v、V    先按v再用上下箭头选中几行，再&lt;         这几行集体左移，再.继续左移</span><br></pre></td></tr></table></figure><h2 id="5、底行模式"><a href="#5、底行模式" class="headerlink" title="5、底行模式"></a>5、底行模式</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----底行模式：----</span><br><span class="line"> </span><br><span class="line">q！                不保存退出</span><br><span class="line">wq                 保存退出</span><br><span class="line"> </span><br><span class="line">%s/abc/<span class="number">123</span>/g       把全文的abc替换成<span class="number">123</span></span><br><span class="line"><span class="number">1</span>,<span class="number">10</span>s/abc/<span class="number">123</span>/g    把<span class="number">1</span><span class="number">-10</span>行的abc替换成<span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">----命令模式：----</span><br><span class="line"> </span><br><span class="line">u            撤销</span><br><span class="line">ctrl+r       反撤销（撤销u操作）</span><br><span class="line">r            修改当前字符</span><br><span class="line">R            从当前位置开始修改，按Esc返回</span><br><span class="line">/            向下搜索，先输入/,再输入搜索内容+回车。<span class="built_in">n</span>、<span class="built_in">N</span>表示上（下）一个搜索结果</span><br><span class="line">? 向上搜索，先输入？,再输入搜索内容+回车。<span class="built_in">n</span>、<span class="built_in">N</span>表示上（下）一个搜索结果</span><br></pre></td></tr></table></figure><h1 id="操作提升-1"><a href="#操作提升-1" class="headerlink" title="操作提升"></a>操作提升</h1><h2 id="7、批量插入、删除"><a href="#7、批量插入、删除" class="headerlink" title="7、批量插入、删除"></a>7、批量插入、删除</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="params">----</span>插入模式：<span class="params">----</span></span><br><span class="line">v进入可视界面，通过上下选中需要操作的行</span><br><span class="line">ctrl+v进行可视化块选中</span><br><span class="line">I输入大写I进入操作界面，输入<span class="comment">#或者//进行注释</span></span><br><span class="line">esc连续按两下esc，完成操作</span><br><span class="line"></span><br><span class="line"><span class="params">----</span>删除模式：<span class="params">----</span></span><br><span class="line">ctrl +v 进入块操作，选中你要删除的字符/行</span><br><span class="line">d单个d删除字符，dd删除行</span><br></pre></td></tr></table></figure><h2 id="8、-删除"><a href="#8、-删除" class="headerlink" title="8、 删除"></a>8、 删除</h2><p>对3的补充</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span>删除一行</span><br><span class="line">ndd删除以当行开始的n行</span><br><span class="line"><span class="built_in">dw</span>删除以当前字符开始的一个字符，比如：abc,dwt。光标在a，<span class="built_in">dw</span>就删除abc</span><br><span class="line">ndw删除以当前字符开始的n个字符</span><br><span class="line">d$、D删除以当前字符开始的一行字符</span><br><span class="line">d)删除到下一句的开始</span><br><span class="line">d&#125;删除到下一段的开始</span><br><span class="line">d回车删除<span class="number">2</span>行</span><br><span class="line">全部删除：按esc后，然后dG</span><br></pre></td></tr></table></figure><h2 id="9、复制多行"><a href="#9、复制多行" class="headerlink" title="9、复制多行"></a>9、复制多行</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">方法1：（强烈推荐）</span></span><br><span class="line"><span class="string">：9，15</span> <span class="string">copy</span> <span class="number">16</span>  <span class="string">或</span> <span class="string">：9，15</span> <span class="string">co</span> <span class="number">16</span><span class="string">将第9行至第15行的数据，复制到第16行</span></span><br><span class="line"><span class="string">：9，15</span> <span class="string">move</span> <span class="number">16</span>  <span class="string">或</span> <span class="string">:9,15</span> <span class="string">m</span> <span class="number">16</span> <span class="string">将第9行到第15行的文本内容到第16行的后面</span> </span><br><span class="line"></span><br><span class="line"><span class="string">方法2：</span></span><br><span class="line"><span class="string">光标移动到结束行，ma</span></span><br><span class="line"><span class="string">光标移动到起始行,输入y'a</span></span><br><span class="line"><span class="string">光标移动到需要复制的行，输入p,行前复制则输入大写P</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">全部复制：按esc后，然后ggyG</span></span><br><span class="line"><span class="string">全选高亮显示：按esc后，然后ggvG或者ggVG</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;入门操作&quot;&gt;&lt;a href=&quot;#入门操作&quot; class=&quot;headerlink&quot; title=&quot;入门操作&quot;&gt;&lt;/a&gt;入门操作&lt;/h1&gt;&lt;h2 id=&quot;1、输入i进入编辑模式，按下esc-ctrl-c-输入-wq-保存，q！不保存强制退出，wq！强制保存&quot;&gt;&lt;a href=&quot;#1、输入i进入编辑模式，按下esc-ctrl-c-输入-wq-保存，q！不保存强制退出，wq！强制保存&quot; class=&quot;headerlink&quot; title=&quot;1、输入i进入编辑模式，按下esc/ctrl+c 输入:wq 保存，q！不保存强制退出，wq！强制保存&quot;&gt;&lt;/a&gt;1、输入i进入编辑模式，按下esc/ctrl+c 输入:wq 保存，q！不保存强制退出，wq！强制保存&lt;/h2&gt;&lt;h1 id=&quot;操作提升&quot;&gt;&lt;a href=&quot;#操作提升&quot; class=&quot;headerlink&quot; title=&quot;操作提升&quot;&gt;&lt;/a&gt;操作提升&lt;/h1&gt;&lt;h2 id=&quot;2、-set-showmode-回车-即可显示提示。&quot;&gt;&lt;a href=&quot;#2、-set-showmode-回车-即可显示提示。&quot; class=&quot;headerlink&quot; title=&quot;2、 :set showmode+回车 即可显示提示。&quot;&gt;&lt;/a&gt;2、 :set showmode+回车 即可显示提示。&lt;/h2&gt;&lt;h2 id=&quot;3、粘贴复制删除等操作&quot;&gt;&lt;a href=&quot;#3、粘贴复制删除等操作&quot; class=&quot;headerlink&quot; title=&quot;3、粘贴复制删除等操作&quot;&gt;&lt;/a&gt;3、粘贴复制删除等操作&lt;/h2&gt;&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;----命令模式：----&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yy	复制光标所在行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;yy	复制光标所在行开始的&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;p	粘贴&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dd	删除光标所在行（实际是剪切）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;dd	删除光标所在行开始的&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;行（剪切）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x	删除当前光标所在的字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X（大写)	删除当前光标前一个字符&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="vim" scheme="https://rogchen.github.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>使用私有服镜像仓库</title>
    <link href="https://rogchen.github.com/2020/12/21/user-aliyun-docker/"/>
    <id>https://rogchen.github.com/2020/12/21/user-aliyun-docker/</id>
    <published>2020-12-21T01:41:42.324Z</published>
    <updated>2020-12-21T01:41:42.324Z</updated>
    
    <content type="html"><![CDATA[<p>1、登录仓库</p><p><code>sudo docker login --username=chenhk128@163.com registry.cn-hangzhou.aliyuncs.com</code></p><p>2、从Registry中拉取镜像</p><p><code>sudo docker pull registry.cn-hangzhou.aliyuncs.com/rogchen/rogchen_public:[镜像版本号]</code></p><p>3、将镜像推送到Registry</p><a id="more"></a><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- [ImageId]换成自己的镜像 ---</span><br><span class="line"> sudo docker login --username=chenhk128@<span class="number">163</span><span class="selector-class">.com</span> registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span>.com</span><br><span class="line"> sudo docker tag [ImageId] registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span>.com/rogchen/rogchen_public:[镜像版本号]</span><br><span class="line"> sudo docker push registry<span class="selector-class">.cn-hangzhou</span><span class="selector-class">.aliyuncs</span>.com/rogchen/rogchen_public:[镜像版本号]</span><br></pre></td></tr></table></figure><p>4、选择合适的镜像仓库地址</p><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且将不会损耗您的公网流量。</p><p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-hangzhou.aliyuncs.com 作为Registry的域名登录，并作为镜像命名空间前缀。</p><p>5、使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br><span class="line">REPOSITORY                                                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">registry.aliyuncs.<span class="keyword">com</span>/acs/agent                                    <span class="number">0.7</span>-dfb6816         <span class="number">37</span>bb9c63c8b2        <span class="number">7</span> days ago          <span class="number">37.89</span> MB</span><br><span class="line"> sudo docker <span class="keyword">tag</span> <span class="number">37</span>bb9c63c8b2 registry-vpc.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/acs/agen<span class="variable">t:0</span>.<span class="number">7</span>-dfb6816</span><br><span class="line">使用<span class="string">"docker images"</span>命令找到镜像，将该镜像名称中的域名部分变更为Registry专有网络地址。</span><br><span class="line"></span><br><span class="line"> sudo docker push registry-vpc.<span class="keyword">cn</span>-hangzhou.aliyuncs.<span class="keyword">com</span>/acs/agen<span class="variable">t:0</span>.<span class="number">7</span>-dfb6816</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、登录仓库&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo docker login --username=chenhk128@163.com registry.cn-hangzhou.aliyuncs.com&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、从Registry中拉取镜像&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo docker pull registry.cn-hangzhou.aliyuncs.com/rogchen/rogchen_public:[镜像版本号]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、将镜像推送到Registry&lt;/p&gt;</summary>
    
    
    
    
    <category term="aliyun" scheme="https://rogchen.github.com/tags/aliyun/"/>
    
    <category term="repository" scheme="https://rogchen.github.com/tags/repository/"/>
    
  </entry>
  
  <entry>
    <title>springboot的configuration跟auto-configuration的区别。</title>
    <link href="https://rogchen.github.com/2020/12/21/springboot-configuration/"/>
    <id>https://rogchen.github.com/2020/12/21/springboot-configuration/</id>
    <published>2020-12-21T01:41:42.324Z</published>
    <updated>2020-12-21T01:41:42.324Z</updated>
    
    <content type="html"><![CDATA[<p>spring-boot提倡通过annotation来进行bean的配置，现在spring-boot里面常用的两种创建bean的方式有auto-configuration和configuration两种方式。</p><h3 id="1、configuration配置的使用。"><a href="#1、configuration配置的使用。" class="headerlink" title="1、configuration配置的使用。"></a>1、configuration配置的使用。</h3><p>在配置文件(添加@configuration的类)跟启动类在同个包路径下可用直接被扫描，因为springbootApplication注解自带ComponentScan,不需要在main方法添加扫描器。<br><a id="more"></a></p><p>注解SpringBootApplication源码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">    @AliasFor(</span><br><span class="line">        annotation = EnableAutoConfiguration.class,</span><br><span class="line">        attribute = &quot;exclude&quot;</span><br><span class="line">    )</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果多模块、jar形式或者不在通过包路径下就需要添加自定义类扫描器，在启动的时候使用@ComponentScan注解会扫描包(路径可以指定，默认的情况下就是这个目录所在的包开始扫描)，这个注解扫到@configuration注解以后，就会初始化这个类下面所有加了@bean的方法，并初始化这个bean</p><p>在application中添加扫描<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class demo &#123;</span><br><span class="line">public static void main(String []args) &#123;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义configuration的配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Slf4j</span><br><span class="line">public class BeanConfig &#123;  </span><br><span class="line">  @Bean  </span><br><span class="line">  public BeanConfiguration beanConfig() &#123; </span><br><span class="line">    log.info(&quot;log bean config&quot;);    </span><br><span class="line">    return new BeanConfiguration();  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2、Auto-configuration配置的使用"><a href="#2、Auto-configuration配置的使用" class="headerlink" title="2、Auto-configuration配置的使用"></a>2、Auto-configuration配置的使用</h3><p>spring-boot有一个@EnableAutoConfiguration注解，他通过读取spring.factories文件里面的EnableAutoConfiguration下面指定的类，来初始化指定类下面的所有加了@bean的方法，并初始化这个bean<br>查看下源码</p><p>@EnableAutoConfiguration<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到有个Import引入类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                    .loadMetadata(this.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">            List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                    attributes);</span><br><span class="line">            configurations = removeDuplicates(configurations);</span><br><span class="line">            configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">            Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">            checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            return configurations.toArray(new String[configurations.size()]);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (IOException ex) &#123;</span><br><span class="line">            throw new IllegalStateException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看如下代码，获取类路径下spring.factories下key为EnableAutoConfiguration全限定名对应值<br>List<string> configurations = getCandidateConfigurations(annotationMetadata,<br>attributes);<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">            AnnotationAttributes attributes) &#123;</span><br><span class="line">        List&lt;String&gt; <span class="keyword">configurations</span> = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">                getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(<span class="keyword">configurations</span>,</span><br><span class="line">                <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">                        + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">configurations</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">        <span class="keyword">return</span> EnableAutoConfiguration.<span class="keyword">class</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></string></p><p>getCandidateConfigurations会到classpath下的读取META-INF/spring.factories文件的配置，并返回一个字符串数组。<br>查看下spring.factories<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># Auto Configure</span></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=<span class="keyword">com</span>.ylzinfo.ms.abc,<span class="keyword">com</span>.ylzinfo.ms.bbc</span><br></pre></td></tr></table></figure></p><h3 id="3、两者差异"><a href="#3、两者差异" class="headerlink" title="3、两者差异"></a>3、两者差异</h3><p>初始化的时机configuration初始化的方式总是在auto-configuration初始化方式之前<br>configuration初始化的顺序和扫描的过程相关，并不能进行有效的进行指定，不方便确定文件加载的顺序<br>auto-configuration可以通过@AutoConfigureAfter  @AutoConfigureBefore 和 @AutoConfigureOrder来指定类的加载顺序<br>configuration初始化会先初始化所有被扫到加了@Configuration文件的@PostConstruct注解然后再初始化这些文件里面的@Bean注解，但是auto-configuration是根据文件来进行初始化的，所以会初始化完一个文件的@PostConstruct注解然后再初始化这个文件的@Bean注解，然后再接着处理另外的文件。<br>所以需要提供bean给其他jar包进行使用的时候，最好使用 auto-configuration 方式（spring-boot-starters里面的都是通过这种方式来进行提供的，他的所有初始化的过程全部在spring-boot-autoconfigure项目中），因为能更好的控制类文件的加载顺序。有助于维护更佳复杂的项目。<br>另外需要注意一点的就是，如果auto-configuration提供的类名称在扫描的路径之中，spring-boot会把这些类作为configuration先进行初始化了，然后@AutoConfigureAfter @AutoConfigureBefore 和 @AutoConfigureOrder 这类指定顺序的注解都会失效。</p><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><p>@EnableAutoConfiguration 作用从classpath中搜索所有META-INF/spring.factories配置文件然后，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration key对应的配置项加载到spring容器<br>只有spring.boot.enableautoconfiguration为true（默认为true）的时候，才启用自动配置<br>@EnableAutoConfiguration还可以进行排除，排除方式有2中，一是根据class来排除（exclude），二是根据class name（excludeName）来排除<br>其内部实现的关键点有<br>1）ImportSelector 该接口的方法的返回值都会被纳入到spring容器管理中<br>2）SpringFactoriesLoader 该类可以从classpath中搜索所有META-INF/spring.factories配置文件，并读取配置</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;spring-boot提倡通过annotation来进行bean的配置，现在spring-boot里面常用的两种创建bean的方式有auto-configuration和configuration两种方式。&lt;/p&gt;
&lt;h3 id=&quot;1、configuration配置的使用。&quot;&gt;&lt;a href=&quot;#1、configuration配置的使用。&quot; class=&quot;headerlink&quot; title=&quot;1、configuration配置的使用。&quot;&gt;&lt;/a&gt;1、configuration配置的使用。&lt;/h3&gt;&lt;p&gt;在配置文件(添加@configuration的类)跟启动类在同个包路径下可用直接被扫描，因为springbootApplication注解自带ComponentScan,不需要在main方法添加扫描器。&lt;br&gt;</summary>
    
    
    
    
    <category term="springboot" scheme="https://rogchen.github.com/tags/springboot/"/>
    
    <category term="configuration" scheme="https://rogchen.github.com/tags/configuration/"/>
    
    <category term="autoconfiguration" scheme="https://rogchen.github.com/tags/autoconfiguration/"/>
    
  </entry>
  
  <entry>
    <title>Rogchen-md学习</title>
    <link href="https://rogchen.github.com/2020/12/21/rogchen-md/"/>
    <id>https://rogchen.github.com/2020/12/21/rogchen-md/</id>
    <published>2020-12-21T01:41:42.322Z</published>
    <updated>2020-12-21T01:41:42.322Z</updated>
    
    <content type="html"><![CDATA[<p>使用#来定义标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="#一级标题"></a>#一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="##二级标题"></a>##二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="###三级标题"></a>###三级标题</h3><h6 id="共有六级标题"><a href="#共有六级标题" class="headerlink" title="######共有六级标题"></a>######共有六级标题</h6><hr><h3 id="1、分割线-就是转义"><a href="#1、分割线-就是转义" class="headerlink" title="1、分割线--\就是转义"></a>1、分割线--\就是转义</h3><p>使用横线（-–上换行或者***或者___）</p><hr><h3 id="2、代码块-gt-单行"><a href="#2、代码块-gt-单行" class="headerlink" title="2、代码块-&gt;单行``"></a>2、代码块-&gt;单行``</h3><p><code>代码块输出使用&quot;`</code>“`</p><h3 id="3、代码块-gt-多行"><a href="#3、代码块-gt-多行" class="headerlink" title="3、代码块-&gt;多行```"></a>3、代码块-&gt;多行```</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;abc&lt;/p&gt;</span><br><span class="line">&lt;p&gt;bbb&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="4、使用大于号”-gt-”表示引用"><a href="#4、使用大于号”-gt-”表示引用" class="headerlink" title="4、使用大于号”&gt;”表示引用"></a>4、使用大于号”&gt;”表示引用</h3><blockquote><ul><li>>一级引用，不以结婚为目的的恋爱都是耍流氓<blockquote><ul><li>>&gt;二级引用<blockquote><ul><li>>&gt;&gt;三级引用</li></ul></blockquote></li></ul></blockquote></li></ul></blockquote><a id="more"></a><h3 id="5、引用图片-title-url"><a href="#5、引用图片-title-url" class="headerlink" title="5、引用图片 ![title](url)"></a>5、引用图片 ![title](url)</h3><p><img src="G:CHK/Desktop/ip.pn" alt="rogchen"></p><blockquote><p>也是支持参数式 []()</p><blockquote><p>[rogchen]:(<a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a>)<br>图片的参数式![rogchen]<br>效果跟上一样。</p></blockquote></blockquote><h3 id="6、无序列表使用-、-或"><a href="#6、无序列表使用-、-或" class="headerlink" title="6、无序列表使用-、+或*"></a>6、无序列表使用-、+或*</h3><ul><li>列表一</li></ul><ul><li>列表二</li></ul><ul><li>列表三</li></ul><h3 id="7、有序列表：有序列表的序号是根据第一行列表的数字顺序来的"><a href="#7、有序列表：有序列表的序号是根据第一行列表的数字顺序来的" class="headerlink" title="7、有序列表：有序列表的序号是根据第一行列表的数字顺序来的"></a>7、有序列表：有序列表的序号是根据第一行列表的数字顺序来的</h3><ol start="3"><li>列表三</li><li>列表四</li><li>列表五</li></ol><h3 id="8、强调：粗体和斜体-gt-一个星号或者是一个下划线包起来，会转换为-lt-em-倾斜，如果是2个，会转换为加粗"><a href="#8、强调：粗体和斜体-gt-一个星号或者是一个下划线包起来，会转换为-lt-em-倾斜，如果是2个，会转换为加粗" class="headerlink" title="8、强调：粗体和斜体-&gt;一个星号或者是一个下划线包起来，会转换为\&lt;em>倾斜，如果是2个，会转换为加粗"></a>8、强调：粗体和斜体-&gt;一个星号或者是一个下划线包起来，会转换为\&lt;em>倾斜，如果是2个，会转换为<strong>加粗</strong></h3><p><em>两个星号(\</em>)包含一段文本就是粗体的语法*</p><p><em>用一个下划线(\</em>)包含一段文本就是斜体的语法_</p><p><strong>**加粗\&lt;strong>**</strong></p><h3 id="9、表格"><a href="#9、表格" class="headerlink" title="9、表格"></a>9、表格</h3><p>|aaaa|vvvvv|<br>|bbbb|ccccc|<br>效果：<br>| table |table1 |<br>| —– |:—–:|<br>| 123   |fwer   |</p><h3 id="10、行内式：直接嵌套-gt-使用链接"><a href="#10、行内式：直接嵌套-gt-使用链接" class="headerlink" title="10、行内式：直接嵌套-&gt;使用链接"></a>10、行内式：直接嵌套-&gt;使用链接</h3><p>[rogchen](<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>)<br>效果：<br><a href="www.baidu.com">rogchen</a></p><h3 id="11、参数式-占位符-gt-支持title"><a href="#11、参数式-占位符-gt-支持title" class="headerlink" title="11、参数式: 占位符-&gt;支持title"></a>11、参数式: 占位符-&gt;支持title</h3><p>[home]: <a href="http://google.com" target="_blank" rel="noopener">http://google.com</a> “谷歌”<br>[支持的哦]: /name/home “瞎写的”<br>这里是[name]，这里是[home]，这也是[支持的哦]</p><blockquote><p>[foo1]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> “Optional Title Here”<br>[foo2]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> ‘Optional Title Here’<br>[foo3]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> (Optional Title Here)<br>[foo4]: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a> “推荐使用这种”<br>这里也是可[foo1]，使用[foo2]，使用[foo3]，使用[foo4]</p></blockquote><h3 id="11、转义"><a href="#11、转义" class="headerlink" title="11、转义"></a>11、转义</h3><blockquote><ul><li>\</li><li>`</li><li>*</li><li>\/</li></ul></blockquote><h3 id="12、删除线使用双"><a href="#12、删除线使用双" class="headerlink" title="12、删除线使用双~~"></a>12、删除线使用双~~</h3><p><del>删除线</del></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用#来定义标题&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;#一级标题&quot;&gt;&lt;/a&gt;#一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;##二级标题&quot;&gt;&lt;/a&gt;##二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;###三级标题&quot;&gt;&lt;/a&gt;###三级标题&lt;/h3&gt;&lt;h6 id=&quot;共有六级标题&quot;&gt;&lt;a href=&quot;#共有六级标题&quot; class=&quot;headerlink&quot; title=&quot;######共有六级标题&quot;&gt;&lt;/a&gt;######共有六级标题&lt;/h6&gt;&lt;hr&gt;
&lt;h3 id=&quot;1、分割线-就是转义&quot;&gt;&lt;a href=&quot;#1、分割线-就是转义&quot; class=&quot;headerlink&quot; title=&quot;1、分割线--\就是转义&quot;&gt;&lt;/a&gt;1、分割线--\就是转义&lt;/h3&gt;&lt;p&gt;使用横线（-–上换行或者***或者___）&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2、代码块-gt-单行&quot;&gt;&lt;a href=&quot;#2、代码块-gt-单行&quot; class=&quot;headerlink&quot; title=&quot;2、代码块-&amp;gt;单行``&quot;&gt;&lt;/a&gt;2、代码块-&amp;gt;单行``&lt;/h3&gt;&lt;p&gt;&lt;code&gt;代码块输出使用&amp;quot;`&lt;/code&gt;“`&lt;/p&gt;
&lt;h3 id=&quot;3、代码块-gt-多行&quot;&gt;&lt;a href=&quot;#3、代码块-gt-多行&quot; class=&quot;headerlink&quot; title=&quot;3、代码块-&amp;gt;多行```&quot;&gt;&lt;/a&gt;3、代码块-&amp;gt;多行```&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;abc&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;p&amp;gt;bbb&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;4、使用大于号”-gt-”表示引用&quot;&gt;&lt;a href=&quot;#4、使用大于号”-gt-”表示引用&quot; class=&quot;headerlink&quot; title=&quot;4、使用大于号”&amp;gt;”表示引用&quot;&gt;&lt;/a&gt;4、使用大于号”&amp;gt;”表示引用&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&gt;一级引用，不以结婚为目的的恋爱都是耍流氓&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&gt;&amp;gt;二级引用&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&gt;&amp;gt;&amp;gt;三级引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="md" scheme="https://rogchen.github.com/tags/md/"/>
    
  </entry>
  
  <entry>
    <title>nginx安装和使用</title>
    <link href="https://rogchen.github.com/2020/12/21/nginx-user/"/>
    <id>https://rogchen.github.com/2020/12/21/nginx-user/</id>
    <published>2020-12-21T01:41:42.321Z</published>
    <updated>2020-12-21T01:41:42.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx的编译安装"><a href="#nginx的编译安装" class="headerlink" title="nginx的编译安装"></a>nginx的编译安装</h1><p><a href="!http://nginx.org/en/download.html">下载nginx</a> 选择版本，我这里使用v1.15.4</p><p>解压</p><p><code>tar xvf nginx-1.15.4.tar.gv</code></p><p>最好重命名该源码<br><code>mv nginx-1.15.4 nginx-1.15.4-source</code></p><p>进入目录cd nginx-1.15.4-source</p><p>使用下面编译安装命令</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/configure  --prefix=/</span>home<span class="regexp">/nginx/</span>nginx-<span class="number">1.15</span>.<span class="number">4</span>  --sbin-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>sbin<span class="regexp">/nginx --conf-path=/</span>home<span class="regexp">/nginx/</span>nginx-<span class="number">1.15</span>.<span class="number">4</span><span class="regexp">/conf/</span>nginx.conf --error-log-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>logs<span class="regexp">/error.log  --http-log-path=/</span>home<span class="regexp">/nginx/</span>nginx-<span class="number">1.15</span>.<span class="number">4</span><span class="regexp">/logs/</span>access.log  --pid-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>pid<span class="regexp">/nginx_6379.pid --lock-path=/</span>home<span class="regexp">/nginx/</span>nginx-<span class="number">1.15</span>.<span class="number">4</span><span class="regexp">/lock/</span>nginx.lock  --user=nginx --<span class="keyword">group</span>=nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>tmp<span class="regexp">/client/</span> --http-proxy-temp-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>tmp<span class="regexp">/proxy/</span> --http-fastcgi-temp-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>tmp<span class="regexp">/fcgi/</span> --http-uwsgi-temp-path=<span class="regexp">/home/</span>nginx<span class="regexp">/nginx-1.15.4/</span>tmp<span class="regexp">/uwsgi --http-scgi-temp-path=/</span>home<span class="regexp">/nginx/</span>nginx-<span class="number">1.15</span>.<span class="number">4</span><span class="regexp">/tmp/</span>scgi --with-pcre</span><br></pre></td></tr></table></figure><a id="more"></a><p>安装</p><p><code>make &amp;&amp; make install</code></p><p>启动有时候会出现目录问题,切换到/home/nginx/nginx-1.15.4下<br><code>mkdir -p tmp/client tmp/proxy tmp/fcgi tmp/scgi lock tmp/uwsgi</code></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;nginx的编译安装&quot;&gt;&lt;a href=&quot;#nginx的编译安装&quot; class=&quot;headerlink&quot; title=&quot;nginx的编译安装&quot;&gt;&lt;/a&gt;nginx的编译安装&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;!http://nginx.org/en/download.html&quot;&gt;下载nginx&lt;/a&gt; 选择版本，我这里使用v1.15.4&lt;/p&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tar xvf nginx-1.15.4.tar.gv&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最好重命名该源码&lt;br&gt;&lt;code&gt;mv nginx-1.15.4 nginx-1.15.4-source&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;进入目录cd nginx-1.15.4-source&lt;/p&gt;
&lt;p&gt;使用下面编译安装命令&lt;/p&gt;
&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.&lt;span class=&quot;regexp&quot;&gt;/configure  --prefix=/&lt;/span&gt;home&lt;span class=&quot;regexp&quot;&gt;/nginx/&lt;/span&gt;nginx-&lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;  --sbin-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;sbin&lt;span class=&quot;regexp&quot;&gt;/nginx --conf-path=/&lt;/span&gt;home&lt;span class=&quot;regexp&quot;&gt;/nginx/&lt;/span&gt;nginx-&lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/conf/&lt;/span&gt;nginx.conf --error-log-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;logs&lt;span class=&quot;regexp&quot;&gt;/error.log  --http-log-path=/&lt;/span&gt;home&lt;span class=&quot;regexp&quot;&gt;/nginx/&lt;/span&gt;nginx-&lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/logs/&lt;/span&gt;access.log  --pid-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;pid&lt;span class=&quot;regexp&quot;&gt;/nginx_6379.pid --lock-path=/&lt;/span&gt;home&lt;span class=&quot;regexp&quot;&gt;/nginx/&lt;/span&gt;nginx-&lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/lock/&lt;/span&gt;nginx.lock  --user=nginx --&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt;=nginx --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --http-client-body-temp-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;tmp&lt;span class=&quot;regexp&quot;&gt;/client/&lt;/span&gt; --http-proxy-temp-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;tmp&lt;span class=&quot;regexp&quot;&gt;/proxy/&lt;/span&gt; --http-fastcgi-temp-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;tmp&lt;span class=&quot;regexp&quot;&gt;/fcgi/&lt;/span&gt; --http-uwsgi-temp-path=&lt;span class=&quot;regexp&quot;&gt;/home/&lt;/span&gt;nginx&lt;span class=&quot;regexp&quot;&gt;/nginx-1.15.4/&lt;/span&gt;tmp&lt;span class=&quot;regexp&quot;&gt;/uwsgi --http-scgi-temp-path=/&lt;/span&gt;home&lt;span class=&quot;regexp&quot;&gt;/nginx/&lt;/span&gt;nginx-&lt;span class=&quot;number&quot;&gt;1.15&lt;/span&gt;.&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;regexp&quot;&gt;/tmp/&lt;/span&gt;scgi --with-pcre&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="nginx" scheme="https://rogchen.github.com/tags/nginx/"/>
    
    <category term="限流" scheme="https://rogchen.github.com/tags/%E9%99%90%E6%B5%81/"/>
    
    <category term="安装" scheme="https://rogchen.github.com/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>通过注解和拦截器或aop实现日志</title>
    <link href="https://rogchen.github.com/2020/12/21/logger-Info/"/>
    <id>https://rogchen.github.com/2020/12/21/logger-Info/</id>
    <published>2020-12-21T01:41:42.319Z</published>
    <updated>2020-12-21T01:41:42.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、使用注解和拦截器"><a href="#一、使用注解和拦截器" class="headerlink" title="一、使用注解和拦截器"></a>一、使用注解和拦截器</h1><hr><h3 id="为什么使用拦截器而不是用过滤器呢？"><a href="#为什么使用拦截器而不是用过滤器呢？" class="headerlink" title="为什么使用拦截器而不是用过滤器呢？"></a>为什么使用拦截器而不是用过滤器呢？</h3><ul><li>拦截器是基于Java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖与servlet容器。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li><li>拦截器可以访问action上下文、值栈里的对象。</li></ul><a id="more"></a><h2 id="1、添加注解"><a href="#1、添加注解" class="headerlink" title="1、添加注解"></a>1、添加注解</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">@Target</span>(ElementType.METHOD)<span class="comment">//方法级别-更多可自行查阅</span></span><br><span class="line"><span class="variable">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="variable">@Documented</span></span><br><span class="line"><span class="variable">@Inherited</span></span><br><span class="line">public <span class="variable">@interface</span> LogRecordAno &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2、添加拦截器"><a href="#2、添加拦截器" class="headerlink" title="2、添加拦截器"></a>2、添加拦截器</h2><h4 id="根据自己的开发环境选择拦截器的注册方式"><a href="#根据自己的开发环境选择拦截器的注册方式" class="headerlink" title="根据自己的开发环境选择拦截器的注册方式"></a>根据自己的开发环境选择拦截器的注册方式</h4><h3 id="2-1-springmvc-版。"><a href="#2-1-springmvc-版。" class="headerlink" title="2.1 springmvc 版。"></a>2.1 springmvc 版。</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.im.core.util.Interceptor.LogRecordInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="2-2-springboot-版。"><a href="#2-2-springboot-版。" class="headerlink" title="2.2 springboot 版。"></a>2.2 springboot 版。</h2><h5 id="如果没法被扫描那就加扫描呗。当然也可以在META-INF下添加spring-factories来配置类路径"><a href="#如果没法被扫描那就加扫描呗。当然也可以在META-INF下添加spring-factories来配置类路径" class="headerlink" title="如果没法被扫描那就加扫描呗。当然也可以在META-INF下添加spring.factories来配置类路径"></a>如果没法被扫描那就加扫描呗。当然也可以在META-INF下添加spring.factories来配置类路径</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void addInterceptors(<span class="type">InterceptorRegistry</span> registry) &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="type">LogRecordInterceptor</span>()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3、拦截器的实现是需要实现HandlerInterceptor的三个方法-preHandle、afterCompletion、postHandle-。"><a href="#3、拦截器的实现是需要实现HandlerInterceptor的三个方法-preHandle、afterCompletion、postHandle-。" class="headerlink" title="3、拦截器的实现是需要实现HandlerInterceptor的三个方法(preHandle、afterCompletion、postHandle)。"></a>3、拦截器的实现是需要实现HandlerInterceptor的三个方法(preHandle、afterCompletion、postHandle)。</h2><h3 id="3-1-preHandle-请求前"><a href="#3-1-preHandle-请求前" class="headerlink" title="3.1 preHandle 请求前"></a>3.1 preHandle 请求前</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   *  </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>回值为false，当preHandle的返回值为false的时候整个请求就结束了。 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   *      </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown">   */</span></span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public boolean preHandle(HttpServletRequest request, HttpServletResponse response, <span class="built_in">Object</span> o) throws Exception &#123;</span><br><span class="line">      <span class="keyword">if</span> (o instanceof HandlerMethod) &#123;</span><br><span class="line">              Method method = ((HandlerMethod) o).getMethod();</span><br><span class="line">              LogRecordAno logRecord = method.getAnnotation(LogRecordAno<span class="class">.<span class="keyword">class</span>);</span></span><br><span class="line"><span class="class">              <span class="title">if</span> (<span class="title">logRecord</span> != <span class="title">null</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 有request就可以拿到 很多参数，这里方便写就用Map做参数容器</span></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; properties = <span class="keyword">new</span> HashMap&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">Object</span> param : request.getParameterMap().keySet()) &#123;</span><br><span class="line">properties.put(param.toString(), request.getParameter(param.toString()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其它的业务 逻辑</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-postHandle-请求时拦截"><a href="#3-2-postHandle-请求时拦截" class="headerlink" title="3.2 postHandle 请求时拦截"></a>3.2 postHandle 请求时拦截</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"><span class="markdown">/** </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">      * </span>这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">      * </span>后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">      * </span>作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像， </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">      * </span>只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">      * </span>或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 </span></span></span><br><span class="line"><span class="comment"><span class="markdown">     */</span></span>  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">public <span class="keyword">void</span> postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, <span class="built_in">Object</span></span><br><span class="line">        o, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-afterCompletion-返回拦截"><a href="#3-3-afterCompletion-返回拦截" class="headerlink" title="3.3 afterCompletion 返回拦截"></a>3.3 afterCompletion 返回拦截</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><span class="markdown">/**</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">   * </span>url记录高于注解记录问题</span></span></span><br><span class="line"><span class="comment"><span class="markdown">   **/</span></span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  public <span class="keyword">void</span> afterCompletion(HttpServletRequest request, HttpServletResponse response, <span class="built_in">Object</span> o, Exception e) throws</span><br><span class="line">          Exception &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="4-1-触发实现"><a href="#4-1-触发实现" class="headerlink" title="4.1 触发实现"></a>4.1 触发实现</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span><br><span class="line"></span><br><span class="line">@LogRecordAno</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">void</span> <span class="params">(<span class="keyword">String</span> userid)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="二、使用aop和注解"><a href="#二、使用aop和注解" class="headerlink" title="二、使用aop和注解"></a>二、使用aop和注解</h1><h2 id="1-添加注解（参考上面）"><a href="#1-添加注解（参考上面）" class="headerlink" title="1.添加注解（参考上面）"></a>1.添加注解（参考上面）</h2><h2 id="2-添加切面"><a href="#2-添加切面" class="headerlink" title="2.添加切面"></a>2.添加切面</h2><blockquote><h3 id="2-1添加jar"><a href="#2-1添加jar" class="headerlink" title="2.1添加jar"></a>2.1添加jar</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="2-2采用切面来做aop处理"><a href="#2-2采用切面来做aop处理" class="headerlink" title="2.2采用切面来做aop处理"></a>2.2采用切面来做aop处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAopAction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(LogAopAction<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//切入点设置到自定义的log注解上---也可以切路径、通配符等</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.rogchen.annotation.LogRecordAno)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pointCutMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录操作日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pointCutMethod()"</span>)  <span class="comment">// 使用上面定义的切入点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordLog</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        Long newtime = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//业务逻辑代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-最终实现"><a href="#3-最终实现" class="headerlink" title="3.最终实现"></a>3.最终实现</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span>&#123;</span></span><br><span class="line">@LogRecordAno</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">void</span> <span class="params">(<span class="keyword">String</span> userid)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、使用注解和拦截器&quot;&gt;&lt;a href=&quot;#一、使用注解和拦截器&quot; class=&quot;headerlink&quot; title=&quot;一、使用注解和拦截器&quot;&gt;&lt;/a&gt;一、使用注解和拦截器&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;为什么使用拦截器而不是用过滤器呢？&quot;&gt;&lt;a href=&quot;#为什么使用拦截器而不是用过滤器呢？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用拦截器而不是用过滤器呢？&quot;&gt;&lt;/a&gt;为什么使用拦截器而不是用过滤器呢？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;拦截器是基于Java的反射机制的，而过滤器是基于函数回调。&lt;/li&gt;
&lt;li&gt;拦截器不依赖与servlet容器，过滤器依赖与servlet容器。&lt;/li&gt;
&lt;li&gt;拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。&lt;/li&gt;
&lt;li&gt;拦截器可以访问action上下文、值栈里的对象。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="注解" scheme="https://rogchen.github.com/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="拦截器" scheme="https://rogchen.github.com/tags/%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    
    <category term="aop" scheme="https://rogchen.github.com/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>在linux使用v2ray进行翻墙</title>
    <link href="https://rogchen.github.com/2020/12/21/linux-v2ray-client/"/>
    <id>https://rogchen.github.com/2020/12/21/linux-v2ray-client/</id>
    <published>2020-12-21T01:41:42.316Z</published>
    <updated>2020-12-21T01:41:42.317Z</updated>
    
    <content type="html"><![CDATA[<p>1、因为v2ray不区分客户端和服务端唯一区分客户端跟服务端是config.json这个配置文件。这样我们就可以直接参照v2ray服务端的安装方式安装客户端。<br>v2ray默认有三种安装方式：脚本安装、手动安装、编译安装。我们这里使用脚本安装。</p><p>2、下载v2ray<br><code>sudo wget https://install.direct/go.sh</code><br>3、下载完成后执行<br><code>sudo bash go.sh</code></p><a id="more"></a><p>4、最重要的一步配置config.json，脚本安装的情况下路径在/etc/v2ray/<br>建议直接从其它v2ray拷一份（不区分系统平台只要是客户端就可）。<br>5、启动<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 使用systemctl</span></span><br><span class="line">sudo systemctl start v2ray</span><br><span class="line"><span class="comment">### 或者使用service</span></span><br><span class="line">sudo<span class="built_in"> service </span>v2ray start</span><br></pre></td></tr></table></figure></p><p>6、浏览器设置：有些浏览器居然可不需要设置，不知道为什么。firefox为例：<br>打开设置-选项-高级-（网络）-设置-手动配置代理（sockes：127.0.0.1,端口根据你客户端的config.json的端口这里是1070）-勾选使用socksv5代理dns。<br><img src="https://raw.githubusercontent.com/Rogchen/rogchen-picture/master/blog-img/v2ray/firefox-setting.png" alt="v2ray">    </p><p>手动安装也很简单：解压后进入目录在v2ray同级目录移入config.json就可以。但是启动命令就变成,其它配置一样。<br><code>/v2ray/v2ray config.json</code></p><p>参考链接：</p><ul><li>v2ray官网：  <a href="https://www.v2ray.com/chapter_00/install.html" target="_blank" rel="noopener">https://www.v2ray.com/chapter_00/install.html</a></li><li>v2ray白话文：<a href="https://toutyrater.github.io/prep/install.html" target="_blank" rel="noopener">https://toutyrater.github.io/prep/install.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;1、因为v2ray不区分客户端和服务端唯一区分客户端跟服务端是config.json这个配置文件。这样我们就可以直接参照v2ray服务端的安装方式安装客户端。&lt;br&gt;v2ray默认有三种安装方式：脚本安装、手动安装、编译安装。我们这里使用脚本安装。&lt;/p&gt;
&lt;p&gt;2、下载v2ray&lt;br&gt;&lt;code&gt;sudo wget https://install.direct/go.sh&lt;/code&gt;&lt;br&gt;3、下载完成后执行&lt;br&gt;&lt;code&gt;sudo bash go.sh&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://rogchen.github.com/tags/linux/"/>
    
    <category term="v2ray" scheme="https://rogchen.github.com/tags/v2ray/"/>
    
    <category term="翻墙" scheme="https://rogchen.github.com/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>linux不起服务占用一个端口</title>
    <link href="https://rogchen.github.com/2020/12/21/linux-port/"/>
    <id>https://rogchen.github.com/2020/12/21/linux-port/</id>
    <published>2020-12-21T01:41:42.313Z</published>
    <updated>2020-12-21T01:41:42.314Z</updated>
    
    <content type="html"><![CDATA[<p>使用nc命令占用端口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">nc -l 8888    ####启用TCP端口，可以直接telnet通</span><br><span class="line">在其他主机上使用nc测试</span><br><span class="line">nc -v -w 1 192.168.1.1 -z 8888</span><br><span class="line">结果</span><br><span class="line">Connection <span class="keyword">to</span> 192.168.1.1 8888<span class="built_in"> port </span>[tcp/ddi-udp-1] succeeded!</span><br><span class="line"></span><br><span class="line">nc -l -u 8888 ####启用UDP端口，无法telnet通，可以使用nc检测。-u表示使用UDP协议</span><br><span class="line">nc -v -w 1 192.168.1.1 -u -z 8888</span><br><span class="line">结果</span><br><span class="line">Connection <span class="keyword">to</span> 192.168.1.1 8888<span class="built_in"> port </span>[udp/ddi-udp-1] succeeded!</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用nc命令占用端口&lt;/p&gt;
&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://rogchen.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>在linux上安装使用ll命令</title>
    <link href="https://rogchen.github.com/2020/12/21/linux-ll/"/>
    <id>https://rogchen.github.com/2020/12/21/linux-ll/</id>
    <published>2020-12-21T01:41:42.312Z</published>
    <updated>2020-12-21T01:41:42.312Z</updated>
    
    <content type="html"><![CDATA[<p>ll并不是linux下一个基本的命令，它实际上是ls -l的一个别名。<br>Ubuntu默认不支持命令ll，必须用 ls -l，这样使用起来不是很方便。<br>如果要使用此命令，可以作如下修改：</p><ul><li>打开 ~/.bashrc<br>找到 #alias ll=’ls -l’，去掉前面的#就可以了。（关闭原来的终端才能使命令生效）<br>这样个人用户可以使用ll命令，当切换成超级用户后，使用ll命令时提示找不到命令，那是因为你只是修改了个人用户的配置，所以，切换成root后做相同的操作即可解决问题。<br>启示：我们可以通过修改~/.bashrc添加任何其他的命令别名。</li></ul><h2 id="还有另外一种实现方法："><a href="#还有另外一种实现方法：" class="headerlink" title="还有另外一种实现方法："></a>还有另外一种实现方法：</h2><a id="more"></a><ul><li>首先直接用vi创建文件“ll”。<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> <span class="keyword">ll</span></span><br></pre></td></tr></table></figure></li></ul><p>在里面写上<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ls -l</span></span><br></pre></td></tr></table></figure></p><p>保存。然后将这个新的“ll”文件copy到usr/bin下，就可以直接使用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ll并不是linux下一个基本的命令，它实际上是ls -l的一个别名。&lt;br&gt;Ubuntu默认不支持命令ll，必须用 ls -l，这样使用起来不是很方便。&lt;br&gt;如果要使用此命令，可以作如下修改：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开 ~/.bashrc&lt;br&gt;找到 #alias ll=’ls -l’，去掉前面的#就可以了。（关闭原来的终端才能使命令生效）&lt;br&gt;这样个人用户可以使用ll命令，当切换成超级用户后，使用ll命令时提示找不到命令，那是因为你只是修改了个人用户的配置，所以，切换成root后做相同的操作即可解决问题。&lt;br&gt;启示：我们可以通过修改~/.bashrc添加任何其他的命令别名。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;还有另外一种实现方法：&quot;&gt;&lt;a href=&quot;#还有另外一种实现方法：&quot; class=&quot;headerlink&quot; title=&quot;还有另外一种实现方法：&quot;&gt;&lt;/a&gt;还有另外一种实现方法：&lt;/h2&gt;</summary>
    
    
    
    
    <category term="linux" scheme="https://rogchen.github.com/tags/linux/"/>
    
    <category term="ls -l" scheme="https://rogchen.github.com/tags/ls-l/"/>
    
    <category term="ll" scheme="https://rogchen.github.com/tags/ll/"/>
    
  </entry>
  
  <entry>
    <title>springboot使用mail群发邮件一</title>
    <link href="https://rogchen.github.com/2020/12/21/javamail/"/>
    <id>https://rogchen.github.com/2020/12/21/javamail/</id>
    <published>2020-12-21T01:41:42.311Z</published>
    <updated>2020-12-21T01:41:42.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原由"><a href="#原由" class="headerlink" title="原由"></a>原由</h3><p>  之前因为业务需要需要搭建一个邮件发送，网上一查一堆，也没什么毛病，这里主要是做个笔记。还有就是为了只会搭建个邮箱群发平台，但是查了一堆资料都是使用个账号，但是目前一些免费的账号都是有发送次数限制的。那是否是不是有多个账号进行群发呢？答案显然是有的。</p><h3 id="javamail介绍"><a href="#javamail介绍" class="headerlink" title="javamail介绍"></a>javamail介绍</h3><p>　　JavaMail API 按照功能可以划分为如下三大类：</p><ul><li><ol><li>创建和解析邮件的API</li></ol></li><li><ol start="2"><li>发送邮件的API</li></ol></li><li><ol start="3"><li>接收邮件的API</li></ol></li></ul><p>　　以上三种类型的API在JavaMail 中由多个类组成，但是主要有四个核心类，我们在编写程序时，记住这四个核心类，就很容易编写出Java邮件处理程序。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/Rogchen/rogchen-picture/master/blog-img/javamail/javamail-api.png" alt="javamail-api">　　</p><ul><li><ol><li>Message 类:javax.mail.Message 类是创建和解析邮件的核心 API，这是一个抽象类，通常使用它的子类javax.mail.internet.MimeMessage 类。它的实例对象表示一份电子邮件。客户端程序发送邮件时，首先使用创建邮件的 JavaMail API 创建出封装了邮件数据的 Message 对象，然后把这个对象传递给邮件发送API（Transport 类） 发送。客户端程序接收邮件时，邮件接收API把接收到的邮件数据封装在Message 类的实例中，客户端程序在使用邮件解析API从这个对象中解析收到的邮件数据。</li></ol></li><li><ol start="2"><li>Transport 类：javax.mail.Transport 类是发送邮件的核心API 类，它的实例对象代表实现了某个邮件发送协议的邮件发送对象，例如 SMTP 协议，客户端程序创建好 Message 对象后，只需要使用邮件发送API 得到 Transport 对象，然后把 Message 对象传递给 Transport 对象，并调用它的发送方法，就可以把邮件发送给指定的 SMTP 服务器。</li></ol></li></ul><ul><li><ol start="3"><li>Store 类：javax.mail.Store 类是接收邮件的核心 API 类，它的实例对象代表实现了某个邮件接收协议的邮件接收对象，例如 POP3 协议，客户端程序接收邮件时，只需要使用邮件接收 API 得到 Store 对象，然后调用 Store 对象的接收方法，就可以从指定的 POP3 服务器获得邮件数据，并把这些邮件数据封装到表示邮件的 Message 对象中。</li></ol></li><li><ol start="4"><li>Session 类：javax.mail.Session 类用于定义整个应用程序所需的环境信息，以及收集客户端与邮件服务器建立网络连接的会话信息，例如邮件服务器的主机名、端口号、采用的邮件发送和接收协议等。Session 对象根据这些信息构建用于邮件收发的 Transport 和 Store 对象，以及为客户端创建 Message 对象时提供信息支持。</li></ol></li></ul><h3 id="java实现过程"><a href="#java实现过程" class="headerlink" title="java实现过程"></a>java实现过程</h3><p>在理解下面通过代码实现邮件的发送时，我们可以将邮件发送假想为火箭运载这卫星发送。其中Message 是卫星，Transport 是火箭，而卫星和火箭的构建都需要 Session 的帮助，这样的关系更加便于记忆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//发件人地址</span><br><span class="line">public static String senderAddress = &quot;***@qq.com&quot;;</span><br><span class="line">//收件人地址</span><br><span class="line">public static String recipientAddress = &quot;***@qq.com&quot;;</span><br><span class="line">//发件人账户名</span><br><span class="line">public static String senderAccount = &quot;****@qq.com&quot;;</span><br><span class="line">//发件人账户密码</span><br><span class="line">public static String senderPassword = &quot;&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//1、连接邮件服务器的参数配置</span><br><span class="line">Properties props = new Properties();</span><br><span class="line">//设置用户的认证方式</span><br><span class="line">props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;);</span><br><span class="line">//设置传输协议</span><br><span class="line">props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);</span><br><span class="line">//设置发件人的SMTP服务器地址</span><br><span class="line">props.setProperty(&quot;mail.smtp.host&quot;, &quot;smtp.qq.com&quot;);</span><br><span class="line">//2、创建定义整个应用程序所需的环境信息的 Session 对象</span><br><span class="line">Session session = Session.getInstance(props);</span><br><span class="line">//设置调试信息在控制台打印出来</span><br><span class="line">session.setDebug(true);</span><br><span class="line">//3、创建邮件的实例对象</span><br><span class="line">Message msg = getMimeMessage(session,senderAddress);</span><br><span class="line">//4、根据session对象获取邮件传输对象Transport</span><br><span class="line">Transport transport = session.getTransport();</span><br><span class="line">//设置发件人的账户名和密码</span><br><span class="line">transport.connect(senderAccount, senderPassword);</span><br><span class="line">//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span><br><span class="line">transport.sendMessage(msg, msg.getAllRecipients());</span><br><span class="line">//如果只想发送给指定的人，可以如下写法</span><br><span class="line">//transport.sendMessage(msg, new Address[]&#123;new InternetAddress(&quot;xxx@qq.com&quot;)&#125;);</span><br><span class="line">//5、关闭邮件连接</span><br><span class="line">transport.close();</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一封邮件的实例对象</span></span><br><span class="line">MimeMessage msg = <span class="keyword">new</span> <span class="type">MimeMessage</span>(session);</span><br><span class="line"><span class="comment">//设置发件人地址</span></span><br><span class="line">msg.setFrom(<span class="keyword">new</span> <span class="type">InternetAddress</span>(senderAddress));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行</span></span><br><span class="line"><span class="comment">* MimeMessage.RecipientType.TO:发送</span></span><br><span class="line"><span class="comment">* MimeMessage.RecipientType.CC：抄送</span></span><br><span class="line"><span class="comment">* MimeMessage.RecipientType.BCC：密送</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">msg.setRecipient(MimeMessage.RecipientType.TO, <span class="keyword">new</span> <span class="type">InternetAddress</span>(recipientAddress));</span><br><span class="line"><span class="comment">//设置邮件主题</span></span><br><span class="line">msg.setSubject(<span class="string">"邮件主题"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">//设置邮件正文</span></span><br><span class="line">msg.setContent(<span class="string">"简单的纯文本邮件！"</span>+senderAddress, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"><span class="comment">//设置邮件的发送时间,默认立即发送</span></span><br><span class="line">msg.setSentDate(<span class="keyword">new</span> <span class="type">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> msg;</span><br></pre></td></tr></table></figure><p>这样就可以发送邮件了，是不是很简单。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;原由&quot;&gt;&lt;a href=&quot;#原由&quot; class=&quot;headerlink&quot; title=&quot;原由&quot;&gt;&lt;/a&gt;原由&lt;/h3&gt;&lt;p&gt;  之前因为业务需要需要搭建一个邮件发送，网上一查一堆，也没什么毛病，这里主要是做个笔记。还有就是为了只会搭建个邮箱群发平台，但是查了一堆资料都是使用个账号，但是目前一些免费的账号都是有发送次数限制的。那是否是不是有多个账号进行群发呢？答案显然是有的。&lt;/p&gt;
&lt;h3 id=&quot;javamail介绍&quot;&gt;&lt;a href=&quot;#javamail介绍&quot; class=&quot;headerlink&quot; title=&quot;javamail介绍&quot;&gt;&lt;/a&gt;javamail介绍&lt;/h3&gt;&lt;p&gt;　　JavaMail API 按照功能可以划分为如下三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;创建和解析邮件的API&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;发送邮件的API&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;接收邮件的API&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;　　以上三种类型的API在JavaMail 中由多个类组成，但是主要有四个核心类，我们在编写程序时，记住这四个核心类，就很容易编写出Java邮件处理程序。&lt;/p&gt;</summary>
    
    
    
    
    <category term="springboot" scheme="https://rogchen.github.com/tags/springboot/"/>
    
    <category term="mail" scheme="https://rogchen.github.com/tags/mail/"/>
    
  </entry>
  
  <entry>
    <title>让hexo的首页只显示文章的部分内容而不是全部</title>
    <link href="https://rogchen.github.com/2020/12/21/hexo-more/"/>
    <id>https://rogchen.github.com/2020/12/21/hexo-more/</id>
    <published>2020-12-21T01:41:42.308Z</published>
    <updated>2020-12-21T01:41:42.309Z</updated>
    
    <content type="html"><![CDATA[<pre><code>Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？</code></pre><p>我们通过下面的三种方式实现:</p><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><hr><p>用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span># Automatically Excerpt. <span class="keyword">Not</span> recommend.</span><br><span class="line"><span class="symbol">2 </span># Please use &lt;!-- more --&gt; in the post <span class="keyword">to</span> control excerpt accurately.</span><br><span class="line"><span class="symbol">3 </span>auto_excerpt:</span><br><span class="line"><span class="symbol">4 </span>  enable: false</span><br><span class="line"><span class="symbol">5 </span>  length: <span class="number">150</span></span><br></pre></td></tr></table></figure><p>把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。<br><a id="more"></a><br>修改后重启 hexo 就ok了。</p><ul><li>效果：修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …。</li></ul><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><hr><p>  在你写 md 文章的时候，可以在内容中加上 &lt;!–more–>，这样首页和列表页展示的文章内容就是 <!--more--> 之前的文字，而之后的就不会显示了。<br>  上面两种方式展示出来的效果是不一样的。</p><ul><li>效果：加上 &lt;!–more–>展示出来的就是你原本文章的样式，最后不会有…。</li></ul><h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><hr><p>在文章的 front-matter 中添加 description，并提供文章摘录<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>title: 让hexo的首页只显示文章的部分内容而不是全部</span><br><span class="line"><span class="symbol">2 </span>id: set-hexo-show-more-button-<span class="keyword">on</span>-index</span><br><span class="line"><span class="symbol">3 </span>date: <span class="number">2017</span>-<span class="number">09</span>-<span class="number">30</span> <span class="number">11</span>:<span class="number">01</span>:<span class="number">40</span></span><br><span class="line"><span class="symbol">4 </span>tags:</span><br><span class="line"><span class="symbol">5 </span>   - blog</span><br><span class="line"><span class="symbol">6 </span>   - hexo</span><br></pre></td></tr></table></figure></p><p>但是使用这种方式生成的描述信息在文章的详情页是不再显示的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr><p>各种方式展示的效果各有好处，第二种方法保留了样式而且可以自行选择显示哪些内容来预览，推荐使用此方法，第一种方法显示的每篇文章的预览都是一样的高度，第三种则需要在文章的[front-matter]{<a href="https://hexo.io/docs/front-matter.html}里面添加。" target="_blank" rel="noopener">https://hexo.io/docs/front-matter.html}里面添加。</a></p><p>参考链接：</p><ul><li><a href="http://www.5isjyx.com/coding/201704/nextreadthefulltext.html" target="_blank" rel="noopener">http://www.5isjyx.com/coding/201704/nextreadthefulltext.html</a></li><li><a href="http://theme-next.iissnan.com/faqs.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/faqs.html</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;pre&gt;&lt;code&gt;Hexo 的 Next 主题默认是首页显示你每篇文章的全文内容，那么要如何设置只显示部分呢？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们通过下面的三种方式实现:&lt;/p&gt;
&lt;h2 id=&quot;第一种方法&quot;&gt;&lt;a href=&quot;#第一种方法&quot; class=&quot;headerlink&quot; title=&quot;第一种方法&quot;&gt;&lt;/a&gt;第一种方法&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;用文本编辑器打开 themes/ 目录下的对应的主题的theme文件夹下的 _config.yml 文件，找到这段代码，如果没有则新建，可能不同的主题会不支持这种方法：&lt;/p&gt;
&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;1 &lt;/span&gt;# Automatically Excerpt. &lt;span class=&quot;keyword&quot;&gt;Not&lt;/span&gt; recommend.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;2 &lt;/span&gt;# Please use &amp;lt;!-- more --&amp;gt; in the post &lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt; control excerpt accurately.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;3 &lt;/span&gt;auto_excerpt:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;4 &lt;/span&gt;  enable: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;5 &lt;/span&gt;  length: &lt;span class=&quot;number&quot;&gt;150&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。&lt;br&gt;</summary>
    
    
    
    
    <category term="hexo" scheme="https://rogchen.github.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://rogchen.github.com/2020/12/21/hello-world/"/>
    <id>https://rogchen.github.com/2020/12/21/hello-world/</id>
    <published>2020-12-21T01:41:42.306Z</published>
    <updated>2020-12-21T01:41:42.307Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.</summary>
      
    
    
    
    
    <category term="web" scheme="https://rogchen.github.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>git命令学习</title>
    <link href="https://rogchen.github.com/2020/12/21/git-learning/"/>
    <id>https://rogchen.github.com/2020/12/21/git-learning/</id>
    <published>2020-12-21T01:41:42.305Z</published>
    <updated>2020-12-21T01:41:42.305Z</updated>
    
    <content type="html"><![CDATA[<p>随着git越来越火，学习好git的常规操作是很有必要。我们从本地-&gt;远程，使用https到使用ssh来介绍使用git</p><h1 id="前言：git的初始化配置"><a href="#前言：git的初始化配置" class="headerlink" title="前言：git的初始化配置"></a>前言：git的初始化配置</h1><h3 id="1、创建文件夹"><a href="#1、创建文件夹" class="headerlink" title="1、创建文件夹"></a>1、创建文件夹</h3><p><code>mkdir 文件名</code></p><h3 id="2、初始化"><a href="#2、初始化" class="headerlink" title="2、初始化"></a>2、初始化</h3><p>初始化本地仓库（.git目录）<br>存放的是本地库配置信息，不要胡乱删除修改。<br><code>git init</code></p><a id="more"></a><h3 id="3、设置签名"><a href="#3、设置签名" class="headerlink" title="3、设置签名"></a>3、设置签名</h3><blockquote><p>3.1 形式： </p><blockquote><p>用户名：rogchen<br>email地址：<a href="mailto:c****@163.com" target="_blank" rel="noopener">c****@163.com</a><br>作用：区分不同开发人员的身份<br>辨析：这里设置的签名和登录远程（代码托管中心）的账号和密码没有任何关系<br>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#设置系统级别</span><br><span class="line">git config --global user.name rogchen </span><br><span class="line">git config --global user.email c****@163.com</span><br><span class="line">#查看是否设置成功，路径：当前用户家目录下 ~/.gitconfig</span><br><span class="line">cat ~/.gitconfig</span><br><span class="line">#设置项目级别</span><br><span class="line">git config user.name rogchen </span><br><span class="line">git config user.email c****@163.com</span><br><span class="line">#查看是否设置成功，路径：当前项目/.git/config</span><br><span class="line">cat .git/config</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><blockquote><blockquote><p>项目级别/仓库级别， 仅在当前目录下有效<br>系统用户基本：登录当前 操作系统的用户范围<br>基本优先级</p><blockquote><p>就近原则：项目基本优先于系统用户级别，二者都有采用项目级别<br>如果只有系统用户级别签名，就以用户级别的签名为准。<br>二者都没有不允许。<br>正常使用全局设置，除非需要指明用户</p></blockquote></blockquote></blockquote><h1 id="正式使用git"><a href="#正式使用git" class="headerlink" title="正式使用git"></a>正式使用git</h1><h2 id="一、-git本地仓库的操作"><a href="#一、-git本地仓库的操作" class="headerlink" title="一、 git本地仓库的操作"></a>一、 git本地仓库的操作</h2><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#查看状态</span></span><br><span class="line">git status #查看工作区/缓冲区的状态</span><br><span class="line"><span class="meta">## on branch master 在主干上</span></span><br><span class="line"><span class="meta">## no commits yet 本地库没有提交文件</span></span><br><span class="line"><span class="meta">## nothing commit *** 没有任何可提交的东西</span></span><br><span class="line"><span class="meta">#添加操作</span></span><br><span class="line">git add 文件 #将文件添加到缓冲区</span><br><span class="line"><span class="meta">#移除操作</span></span><br><span class="line">git rm --cached 文件名 #从缓冲区将文件移除</span><br><span class="line"><span class="meta">#提交操作 可使用 git commit 文件名 #打开vim进行备注体检</span></span><br><span class="line"><span class="meta">#在vim 编辑器使用:set nu 来显示行号</span></span><br><span class="line">git commit -m 备注 可带文件名（默认提交所有） #提交到本地仓库</span><br><span class="line"><span class="meta"># 提交的远程仓库</span></span><br><span class="line">git push master origin</span><br></pre></td></tr></table></figure><h2 id="二、git版本管理"><a href="#二、git版本管理" class="headerlink" title="二、git版本管理"></a>二、git版本管理</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看git提交历史，多屏显示时：空格向下翻页，b向上翻页，q退出</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#从最后一次提交到第一次提交显示从上往下</span></span><br><span class="line"><span class="comment">## 用漂亮格式显示日志，完整hash值</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span></span><br><span class="line"><span class="comment">## 用漂亮格式显示日志，更简洁的，只显示部分hash值</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--onelinx</span></span><br><span class="line"><span class="comment">## 使用指针 需要到那步Head@&#123;3&#125;，移动到当前版本需要3步</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment">#1、基于索引值操作-推荐</span></span><br><span class="line">git reset <span class="comment">--hard （部分）索引值 </span></span><br><span class="line"><span class="comment">#2、基于^符号操作 只能往后退配合 --oneline方便</span></span><br><span class="line">git reset <span class="comment">--hard HEAD^ #默认退一步，退两步HEAD^^</span></span><br><span class="line"><span class="comment">#3、基于~符号操作 配合reflog梗简洁</span></span><br><span class="line">git reset <span class="comment">--hard HEAD~n #退n步</span></span><br></pre></td></tr></table></figure><p>推荐使用索引来操作，其它需要手动数部署<br>命令差别 reset命令三个参数 –sort;–mixed;–hard<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># --soft</span></span><br><span class="line"><span class="meta">## 仅仅在本地库移动HEAD指针(版本差距在缓冲区，本地文件不会变，凸显缓冲区文件)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># --mixed</span></span><br><span class="line"><span class="meta">##在本地库移动HEAD指针，重置缓冲区（本地文件不会变，凸显本地文件）</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># --hard</span></span><br><span class="line"><span class="meta">## 在本地库移动HEAD指针，重置缓冲区，重置工作区（重置）</span></span><br></pre></td></tr></table></figure></p><p>常用hard命令来重置</p><h2 id="三、从删除文件恢复"><a href="#三、从删除文件恢复" class="headerlink" title="三、从删除文件恢复"></a>三、从删除文件恢复</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rm 文件 <span class="comment">#本地删除</span></span><br><span class="line">git add 删除的文件</span><br><span class="line">git <span class="keyword">commit</span> -m 删除文件 文件名</span><br><span class="line"><span class="comment">#找回使用</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 版本号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件 删除添加到缓冲区未提交到到本地仓库,使用下面命令找回</span></span><br><span class="line">git <span class="keyword">reset</span> <span class="comment">--hard 指针位置/HEAD #删除已提交到历史位置或当前位置（已提交本地仓库），删除未提交到本地仓库：HEAD</span></span><br></pre></td></tr></table></figure><h3 id="文件比较-diff"><a href="#文件比较-diff" class="headerlink" title="文件比较-diff"></a>文件比较-diff</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有参数就是工作区跟缓冲区比较</span></span><br><span class="line">git <span class="keyword">diff </span>文件名</span><br><span class="line"><span class="comment"># 使用指针，本地库中的历史版本。就是工作区和本地库历史记录比较</span></span><br><span class="line">git <span class="keyword">diff </span>HEAD^ 文件名</span><br></pre></td></tr></table></figure><p>不指明文件名比较所有</p><h2 id="四、分支-冲突"><a href="#四、分支-冲突" class="headerlink" title="四、分支/冲突"></a>四、分支/冲突</h2><p>好处：<br>1、同时并行推进多个功能开发，提高开发效率。<br>2、各个分支在开发过程中，如果某个分支开发失败，不回对其它分支有影响，失败的分支删除即可。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#查看所有分支</span></span><br><span class="line">git branch -v</span><br><span class="line"><span class="meta"># 创建分支</span></span><br><span class="line">git branch 分支名</span><br><span class="line"><span class="meta"># 切换分支</span></span><br><span class="line">git checkout 分支名</span><br><span class="line"><span class="meta">#合并分支 分支线提交到仓库</span></span><br><span class="line"><span class="meta">## a、切换到被合并分支master（也可以其它分支合并到另外分支）</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">## b、执行merge命令</span></span><br><span class="line">git merge 新内容分支名</span><br><span class="line"><span class="meta"># 解决冲突</span></span><br><span class="line"><span class="meta">## a、合并分支 git merge 文件名</span></span><br><span class="line"><span class="meta">## b、查看冲突文件去编辑它 vim</span></span><br><span class="line"><span class="meta">## c、vim好冲突的内容保存，使用git add 提交修改</span></span><br><span class="line"><span class="meta">## d、使用git commit -m 备注 不能带文件名，</span></span><br><span class="line"><span class="meta">## 善用git status来查看文件状态。</span></span><br></pre></td></tr></table></figure></p><h2 id="五、提交到远程仓库"><a href="#五、提交到远程仓库" class="headerlink" title="五、提交到远程仓库"></a>五、提交到远程仓库</h2><p>本地仓库创建完成<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#查看已有远程仓库地址</span></span><br><span class="line">git remote -v</span><br><span class="line"><span class="meta">#将远程地址起别名 origin代表https://**方便记忆</span></span><br><span class="line">git remote add origin https:<span class="comment">//github.com/rogchen/test.git</span></span><br><span class="line"><span class="meta">#推送命令</span></span><br><span class="line">git push origin master</span><br><span class="line"><span class="meta">#git push 如果当前分支与多个主机存在追踪关系（存在origin origin1 origin2），那么这个时候-u选项会指定一个默认主机，这样后面就可以不加任何参数使用git push。</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></p><h2 id="六、克隆远程仓库"><a href="#六、克隆远程仓库" class="headerlink" title="六、克隆远程仓库"></a>六、克隆远程仓库</h2><p>clone 介绍</p><blockquote><p>a、完整的把远程库下到本地<br>b、创建origin远程地址别名<br>c、初始化本地库<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://***.git</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="七、将其它用户添加到远程仓库管理"><a href="#七、将其它用户添加到远程仓库管理" class="headerlink" title="七、将其它用户添加到远程仓库管理"></a>七、将其它用户添加到远程仓库管理</h2><p>去github 选中仓库-collaborators-选择用户。<br>用户访问邀请地址-接送<br>这时候用户就可以推送到test这个仓库了。</p><h2 id="八、拉取pull命令"><a href="#八、拉取pull命令" class="headerlink" title="八、拉取pull命令"></a>八、拉取pull命令</h2><p>pull是fetch(拉)和merge(合并)操作<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取远程内容-不该本地工作区内容</span></span><br><span class="line">git fetch origin <span class="literal">master</span></span><br><span class="line"><span class="comment"># 查看我们抓起内容</span></span><br><span class="line">git checkout origin/<span class="literal">master</span></span><br><span class="line"><span class="comment">#这时候使用查看命令就可以看到抓取内容了</span></span><br><span class="line">cat 文件名</span><br><span class="line"><span class="comment">#切回本地库</span></span><br><span class="line">git checkout <span class="literal">master</span></span><br><span class="line"><span class="comment">#远程库合并到本地库</span></span><br><span class="line">git merge origin/<span class="literal">master</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#简单使用拉起命令-无法比对</span></span><br><span class="line">git pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure></p><h3 id="使用审核功能-pull-request"><a href="#使用审核功能-pull-request" class="headerlink" title="使用审核功能  pull request"></a>使用审核功能  pull request</h3><p>使用新用户访问test仓库进行fork操作<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">新用户的项目地址.git</span></span><br><span class="line"><span class="comment"># 修改提交-记得使用新用户账号</span></span><br><span class="line">git push origin <span class="literal">master</span></span><br><span class="line"><span class="comment"># 成功提交到新用户的远程仓库</span></span><br></pre></td></tr></table></figure></p><p>进入github管理界面-选择pull requests-选择creat pull requests</p><blockquote><p>切换到主干用户的github管理界面<br>选择pull requests-查看新用户提交的pull requests-files changed<br>进行文件的修改，如果没有问题就进行 merge pull request进行合并代码。</p></blockquote><h2 id="九、远程仓库冲突"><a href="#九、远程仓库冲突" class="headerlink" title="九、远程仓库冲突"></a>九、远程仓库冲突</h2><p>用户1提交了更新<br>用户2提交了同个文件更新<br>这时候报错处于mereging状态<br>跟本地仓库解决冲突一样。</p><p>要点：</p><blockquote><p>a、如果不是基于github远程库最新版所作的修改，不能推送，必须先拉取。<br>b、拉取下来如果进入冲突，则按照“分支冲突解决”操作的方法解决即可。</p></blockquote><h2 id="十、使用ssh登录"><a href="#十、使用ssh登录" class="headerlink" title="十、使用ssh登录"></a>十、使用ssh登录</h2><p>使用ssh来链接github这样只能使用当前用户,https操作可用切换用户进行多用户操作。<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 生成rsa的信息</span></span><br><span class="line">ssh-keygen -t rsa -C 邮箱地址</span><br><span class="line"><span class="meta">#新建ssh的远程地址别名</span></span><br><span class="line">git remote add origin_ssh git@****仓库地址</span><br><span class="line"><span class="meta">## 接下来操作都是用origin_ssh</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;随着git越来越火，学习好git的常规操作是很有必要。我们从本地-&amp;gt;远程，使用https到使用ssh来介绍使用git&lt;/p&gt;
&lt;h1 id=&quot;前言：git的初始化配置&quot;&gt;&lt;a href=&quot;#前言：git的初始化配置&quot; class=&quot;headerlink&quot; title=&quot;前言：git的初始化配置&quot;&gt;&lt;/a&gt;前言：git的初始化配置&lt;/h1&gt;&lt;h3 id=&quot;1、创建文件夹&quot;&gt;&lt;a href=&quot;#1、创建文件夹&quot; class=&quot;headerlink&quot; title=&quot;1、创建文件夹&quot;&gt;&lt;/a&gt;1、创建文件夹&lt;/h3&gt;&lt;p&gt;&lt;code&gt;mkdir 文件名&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、初始化&quot;&gt;&lt;a href=&quot;#2、初始化&quot; class=&quot;headerlink&quot; title=&quot;2、初始化&quot;&gt;&lt;/a&gt;2、初始化&lt;/h3&gt;&lt;p&gt;初始化本地仓库（.git目录）&lt;br&gt;存放的是本地库配置信息，不要胡乱删除修改。&lt;br&gt;&lt;code&gt;git init&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://rogchen.github.com/tags/git/"/>
    
    <category term="linux" scheme="https://rogchen.github.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用eureka注册中心</title>
    <link href="https://rogchen.github.com/2020/12/21/eureka-config/"/>
    <id>https://rogchen.github.com/2020/12/21/eureka-config/</id>
    <published>2020-12-21T01:41:42.303Z</published>
    <updated>2020-12-21T01:41:42.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、单机下"><a href="#1、单机下" class="headerlink" title="1、单机下"></a>1、单机下</h2><p>  推荐使用idea快速构造springboot工程，自动引入相关配置文件。</p><p>引入相关pom文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在启动文件***Application.java上添加注解</p><p>  <code>@EnableEurekaServer</code></p><p>配置注册中心配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#eureka配置信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span> <span class="comment">#注册中心自我保护机制-true打开默认true,false关闭</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60000</span> <span class="comment">#修改检查失效服务的时间。</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rogchen.net</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span> <span class="comment">#false:不作为一个客户端注册到注册中心</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server</span></span><br><span class="line"><span class="comment">#    service-url:</span></span><br><span class="line"><span class="comment">#      defaultZone: http://$&#123;eureka.instance.hostname&#125;:10801/eureka/</span></span><br></pre></td></tr></table></figure><hr><h2 id="2、集群化部署"><a href="#2、集群化部署" class="headerlink" title="2、集群化部署"></a>2、集群化部署</h2><p>集群化部署跟单机区别在于本身也相当于一个服务注册到另外的eureka上去。<br>所以需要在启动类上新增另个注解。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@EnableEurekaClient</span></span><br><span class="line"><span class="variable">@EnableDiscoveryClient</span></span><br></pre></td></tr></table></figure><p>二选一都可.spring cloud中discovery service有许多种实现（eureka、consul、zookeeper等等），@EnableDiscoveryClient基于spring-cloud-commons, @EnableEurekaClient基于spring-cloud-netflix。<br>其实用更简单的话来说，就是如果选用的注册中心是eureka，那么就推荐@EnableEurekaClient，如果是其他的注册中心，那么推荐使用@EnableDiscoveryClient。</p><p>另个差别就是在配置文件上面了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line"><span class="comment">#注册中心自我保护机制-true打开,默认true,false关闭</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#修改检查失效服务的时间。</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">60000</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rogchen.com</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment">#false:不作为一个客户端注册到注册中心,集群作为一个客户端应该true，默认true</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">true</span> </span><br><span class="line"> <span class="comment">#为true时，可以启动，但报异常：Cannot execute request on any known server,</span></span><br><span class="line"> <span class="comment">#集群情况下必须设置为true。</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line"><span class="comment">#另个或者多个eurek的注册地址，使用','分割</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:10801/eureka/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、单机下&quot;&gt;&lt;a href=&quot;#1、单机下&quot; class=&quot;headerlink&quot; title=&quot;1、单机下&quot;&gt;&lt;/a&gt;1、单机下&lt;/h2&gt;&lt;p&gt;  推荐使用idea快速构造springboot工程，自动引入相关配置文件。&lt;/p&gt;
&lt;p&gt;引入相关pom文件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="eureka" scheme="https://rogchen.github.com/tags/eureka/"/>
    
    <category term="springcloud" scheme="https://rogchen.github.com/tags/springcloud/"/>
    
    <category term="微服务" scheme="https://rogchen.github.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>hexo私密功能</title>
    <link href="https://rogchen.github.com/2020/12/21/draft/"/>
    <id>https://rogchen.github.com/2020/12/21/draft/</id>
    <published>2020-12-21T01:41:42.301Z</published>
    <updated>2020-12-21T01:41:42.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-草稿相当于很多博客都有的“私密文章”功能。"><a href="#1-草稿相当于很多博客都有的“私密文章”功能。" class="headerlink" title="1.草稿相当于很多博客都有的“私密文章”功能。"></a>1.草稿相当于很多博客都有的“私密文章”功能。</h3><ul><li>会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type">draft</span> <span class="string">"new draft"</span></span><br></pre></td></tr></table></figure></li></ul><p>如果你希望强行预览草稿，更改配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">render_drafts:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>或者，如下方式启动server：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo<span class="built_in"> server </span>--drafts</span><br></pre></td></tr></table></figure></p><p>下面这条命令可以把草稿变成文章，或者页面：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2.常用命令"></a>2.常用命令</h3><a id="more"></a><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"postName"</span> #新建文章</span><br><span class="line">hexo new<span class="built_in"> page </span><span class="string">"pageName"</span> #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo<span class="built_in"> server </span>#开启预览访问端口（默认端口4000，<span class="string">'ctrl + c'</span>关闭server）</span><br><span class="line">hexo deploy #将.deploy目录部署到GitHub</span><br></pre></td></tr></table></figure><p>组合命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy -g</span><br><span class="line">hexo<span class="built_in"> server </span>-g</span><br></pre></td></tr></table></figure></p><p>简写命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p><h3 id="3-搜索引擎"><a href="#3-搜索引擎" class="headerlink" title="3.搜索引擎"></a>3.搜索引擎</h3><ul><li>你可以到<a href="http://www.sousuoyinqingtijiao.com/" title="Optional Title Here" target="_blank" rel="noopener">屈站长</a>提交你的站点给搜索引擎。其他内容如添加站点或页面的description，提交Sitemap，添加百度统计，Google Analytics等等，参考本文其他章节的内容，不再一一阐述。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;1-草稿相当于很多博客都有的“私密文章”功能。&quot;&gt;&lt;a href=&quot;#1-草稿相当于很多博客都有的“私密文章”功能。&quot; class=&quot;headerlink&quot; title=&quot;1.草稿相当于很多博客都有的“私密文章”功能。&quot;&gt;&lt;/a&gt;1.草稿相当于很多博客都有的“私密文章”功能。&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。&lt;figure class=&quot;highlight haxe&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;draft&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;new draft&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你希望强行预览草稿，更改配置文件：&lt;br&gt;&lt;figure class=&quot;highlight yaml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;render_drafts:&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者，如下方式启动server：&lt;br&gt;&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo&lt;span class=&quot;built_in&quot;&gt; server &lt;/span&gt;--drafts&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;下面这条命令可以把草稿变成文章，或者页面：&lt;br&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo publish [layout] &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;filename&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-常用命令&quot;&gt;&lt;a href=&quot;#2-常用命令&quot; class=&quot;headerlink&quot; title=&quot;2.常用命令&quot;&gt;&lt;/a&gt;2.常用命令&lt;/h3&gt;</summary>
    
    
    
    
    <category term="draft" scheme="https://rogchen.github.com/tags/draft/"/>
    
    <category term="hexo" scheme="https://rogchen.github.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>windows通过命令获取连接过的所有wifi和密码</title>
    <link href="https://rogchen.github.com/2020/12/21/cmd_wifi/"/>
    <id>https://rogchen.github.com/2020/12/21/cmd_wifi/</id>
    <published>2020-12-21T01:41:42.298Z</published>
    <updated>2020-12-21T01:41:42.298Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在windows 打开dos（win+r）输入下面命令就列出很多行 你以前连接过的wifi信息、加密方式、包括密码<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> /f <span class="string">"skip=9 tokens=1,2 delims=:"</span> %i <span class="keyword">in</span> (<span class="string">'netsh wlan show profiles'</span>) <span class="keyword">do</span>  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=<span class="keyword">clear</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;在windows 打开dos（win+r）输入下面命令就列出很多行 你以前连接过的wifi信息、加密方式、包括密码&lt;figure class=&quot;highlight mel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    
    <category term="wifi" scheme="https://rogchen.github.com/tags/wifi/"/>
    
    <category term="cmd" scheme="https://rogchen.github.com/tags/cmd/"/>
    
  </entry>
  
</feed>
